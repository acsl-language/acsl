%; whizzy-master "main.tex"

\chapter{Specification language}
\label{chap:base}

\section{Lexical rules}
\label{sec:lexicalrules}

Specification language text is placed inside special C\ifCPP{/C++} comments; 
its lexical structure mostly follows that of ANSI/ISO C\ifCPP{/C++}. A few differences
should be noted.
\begin{itemize}
\item The at sign (\verb|@|) is equivalent
  to a space character, except where it indicates the beginning of an ACSL\ifCPP{/ACSL++} annotation.
\item Identifiers may start with the backslash character (\verb|\|).
\item Some UTF8 characters may be used in place of some constructs, as
  shown in the following table:

  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      \lstinline|>=| & \ensuremath{\geq} & 0x2265 \\
      \hline
      \lstinline|<=| & \ensuremath{\leq} & 0x2264 \\
      \hline
      \lstinline|>| & \ensuremath{>} & 0x003E \\
      \hline
      \lstinline|<| & \ensuremath{<} & 0x003C \\
      \hline
      \lstinline|\in| & \ensuremath{\in} & 0x2208 \\
      \hline
      \lstinline|!=| & \ensuremath{\not\equiv} & 0x2262 \\
      \hline
      \lstinline|==| & \ensuremath{\equiv} & 0x2261 \\
      \hline
      \lstinline|==>| & \ensuremath{\Longrightarrow} & 0x21D2 \\
      \hline
      \lstinline|<==>| & \ensuremath{\Longleftrightarrow} & 0x21D4 \\
      \hline
      \lstinline|&&| & \ensuremath{\land} & 0x2227 \\
      \hline
      \lstinline+||+ & \ensuremath{\lor} & 0x2228 \\
      \hline
      \lstinline+^^+ (xor) & \underline{\ensuremath{\lor}} & 0x22BB \\
      \hline
      \lstinline+!+ & \ensuremath{\neg} & 0x00AC \\
      \hline
      \lstinline+-+ (unary minus) & \ensuremath{-} & 0x2212 \\
      \hline
      \lstinline|\forall| & \ensuremath{\forall} & 0x2200 \\
      \hline
      \lstinline|\exists| & \ensuremath{\exists} & 0x2203 \\
      \hline
      \lstinline|integer| & \ensuremath{\mathbb{Z}} & 0x2124 \\
      \hline
      \lstinline|real| & \ensuremath{\mathbb{R}} & 0x211D \\
      \hline
      \lstinline|boolean| & \ensuremath{\mathbb{B}} & 0x1D539 \\
      \hline
      \lstinline|\pi| & \ensuremath{\pi} & 0x3C0 \\
      \hline
    \end{tabular}
  \end{center}
\item Comments may be put inside ACSL annotations. They use the C++
  format, {\it i.e.} begin with \texttt{//} and extend to the end of
  current line. Comments beginning with \texttt{/*} may not be nested within ACSL comments. Nested annotations beginning
  with \texttt{//@} are parsed as if the \texttt{//@} is 
  replaced by white space. An ACSL annotation that contains only white space (after
  pre-processing) is ignored.
  \item \NAME uses some grammar elements from \lang, such as literals, type expressions, statements and declarations. Most of these are identified as 
  such by \lstinline|C-| prefixes in the figures laying out the grammar.
  They are described in more detail for reference in Appendix \ref{sec:cgrammar}.
 \end{itemize}

%A bit complicated with listings
%In this document, we use UTF8 characters in the examples, to improve
%readability.

\section{Logic expressions}
\label{sec:expressions}

This first section presents the language of expressions one can use in
annotations. These are called \emph{logic expressions} in the following. They
correspond to pure C expressions, with additional constructs
that we will introduce progressively.

\begin{figure}[t]
  \begin{cadre}
    \input{term.bnf}
  \end{cadre}
  \caption{Grammar of terms. The terminals \emph{id}, \emph{C-type-name}, and various literals are
  	the same as the corresponding C lexical tokens (cf. \S\ref{sec:cgrammar}).}
\label{fig:gram:term}
\end{figure}

\begin{figure}[hb]
  \begin{cadre}
    \input{predicate.bnf}
  \end{cadre}
  \caption{Grammar of predicates}
\label{fig:gram:pred}
\end{figure}

Figures~\ref{fig:gram:term}~and~\ref{fig:gram:pred} present the
grammar for the basic constructs of logic expressions. In that
grammar, we distinguish between \emph{predicates}\index{predicate} and
\emph{terms}\index{term}, following the usual distinction between
propositions and terms in classical first-order logic.
\ifCPP{\footnote{Although this distinction is traditional in mathematical logic, it is now less common in specification languages because the grammars for terms and predicates are so similar. Predicates can be seen simply as logic functions with boolean return values, particularly in languages with a built-in boolean type, such as \lang and \NAME. Although it would simplify the grammar and parsing tools considerably to unify predicates and terms, the Frama-C implementation has separate AST structures for the two and so such a collapsing of the grammar would require a very significant refactoring.}}
For reference, Fig. \ref{fig:gram:ctype} gives the C grammar for a C type expressions.
 
 The grammar
for binders and type expressions is given separately in
Figure~\ref{fig:gram:binders}. 
Although a \textit{type-name} in the C grammar is actually an abstract type expression, possibly including qualifiers and pointer and array decorators,
here we need to distinguish between raw type names (\lstinline|C-type-name|) and type expressions (\lstinline|C-type-expr|); Fig. \ref{fig:gram:ctype} is adapted from the C grammar to show this distinction.
A \lstinline|type-expr| as used in Fig. \ref{fig:gram:binders} and other grammar productions can be
either a logic type name or a C-type expression. 
Note that declarations can differ slightly between C and ACSL logic. For example, C might declare \lstinline|arr| as
\lstinline|int arr[]|, whereas in many places (e.g. Fig. \ref{fig:gram:logic}), ACSL would write \lstinline|int[] arr|.

To understand the grammar, keep in mind the following distinctions:
\begin{itemize}
\item An \lstinline|id| is a basic alphanumeric identifier, used to denote all manner of language constructs (cf. \S\ref{sec:cgrammar}).
\item A \lstinline|poly-id| is an \lstinline|id| to be used in a declaration or definition of that identifier, possibly with formal type or label arguments\ifCPP{, and, in \NAME possibly scope qualifiers}.
\item An \lstinline|ident| is a reference to a previously declared programming or specification language item; syntactically it is an \lstinline|id| possibly decorated with type arguments and memory state labels\ifCPP{, and in \NAME possibly with scope qualifiers}.
\end{itemize}

With respect to C pure expressions, the additional constructs are as follows:
\begin{description}
\item[Additional connectives] C operators \lstinline|&&| (UTF8:
  $\land$), \lstinline+||+ (UTF8: $\lor$) and \lstinline|!| (UTF8:
  $\neg$) are used as logical connectives. There are additional
  connectives \lstinline|==>| (UTF8: $\Longrightarrow$) for
  implication, \lstinline|<==>| (UTF8: $\Longleftrightarrow$) for
  equivalence and \lstinline|^^| (UTF8: \underline{\ensuremath{\lor}})
  for exclusive
  or. These logical connectives all have a bitwise counterpart, either
  C ones like \lstinline|&|, \lstinline+|+, \lstinline|~| and
  \lstinline|^|, or additional ones like bitwise implication
  \lstinline|-->| and bitwise equivalence \lstinline|<-->|.

\item[Quantification] Universal quantification is denoted by
  \lstinline|\forall $\tau$ $x_1$,$\ldots$,$x_n$; e| and existential
  quantification by \lstinline|\exists $\tau$ $x_1$,$\ldots$,$x_n$; e|.

\begin{figure}[t]
  \begin{cadre} \input{binders.bnf}
    \end{cadre}
  \caption{Grammar of binders and type expressions}
\label{fig:gram:binders}
\end{figure}

\item[Local binding]
    \lstinline|\let $x$ = $e_1$;$e_2$|
    introduces the name \lstinline|$x$| for
    expression \lstinline|$e_1$|; \lstinline|$x$| can then be used in expression
    \lstinline|$e_2$|.

\item[Conditional] \lstinline|$c$ ? $e_1$ : $e_2$|. There is a subtlety
  here: the condition may be either a boolean term or a predicate.  In
  case of a predicate, the two branches must be also predicates, so
  that this construct acts as a connective with the following
  semantics: \lstinline|$c$ ? $e_1$ : $e_2$| is equivalent to
  \lstinline|($c$ ==> $e_1$) && (! $c$ ==> $e_2$)|.

\item[Syntactic naming] \lstinline|id : e| is a term or a predicate
  equivalent to $e$. It is different from local naming with \lstinline|\let|:
  the name cannot be reused in other terms or predicates. It is only
  for readability purposes.

\item[Functional modifier]
  The composite element modifier is an additional
  operator related to C structure field and array accessors.
  The expression \lstinline|{ s \with .id = v }|
  denotes a structure value that is the same as the value of \lstinline|s|, except for the field
  \lstinline|id|, which is equal to \lstinline|v|.
  The equivalent expression for an array is
  \lstinline|{ t \with [ i ] = v }|,
  which returns an array with the same value as \lstinline|t|, except for the
  \lstinline|i$^{th}$| element whose value
  is \lstinline|v|.
  See section~\ref{sec:func-dep} for an example use of these operators.

\item[Logic functions] Applications in terms and in propositions are not
applications of C functions, but of logic functions or predicates; see
Section~\ref{sec:logicspec} for detail.

\item[Consecutive comparison operators]
  The construct
\lstinline|$t_1$ $relop_1$ $t_2$ $relop_2$ $t_3$ $\cdots$ $t_k$| with
  several consecutive comparison operators is a shortcut for
  \lstinline|($t_1$ $relop_1$ $t_2$) && ($t_2$ $relop_2$ $t_3$) && $\cdots$|.
  It is required that the \lstinline|$relop_i$| operators must be in
  the same ``direction'', \emph{i.e.} they must all belong either to
  $\{$\lstinline|<|, \lstinline|<=|, \lstinline|==|$\}$ or to
  $\{$\lstinline|>|, \lstinline|>=|, \lstinline|==|$\}$. Expressions such as
  \lstinline|x < y > z| or \lstinline|x != y != z| are not allowed.
  Furthermore the types of each of the terms being compared must be non-boolean.
  Note that consecutive comparison operators are allowed only 
  in predicate position.
  
  \end{description}

  A consecutive comparison as the conditional expression in a ternary operation could, according to the grammar, be either in term or 
  predicate position. In such a case, the conditional expression is
  considered a predicate. As a term a consecutive comparison that includes less-than or greater-than operations
  \lstinline|x < y < z| would
  be parsed as \lstinline|(x < y) < z| which is incorrectly typed, 
  because in logic expressions, comparisons result in boolean values. 
  However, when equalities are involved there could be some ambiguity.
  Consider \lstinline|a < b == c|. As a standard expression, this would be parsed as
  \lstinline|(a < b) == c|, which would require that \lstinline|c| be a boolean value.
  As a consecutive comparison, this would be interpreted as 
  \lstinline|(a < b) && (b == c)|; this form is only type-valid if \lstinline|b| and
  \lstinline|c| have the types that can be compared. However, as integer values are
  implicitly converted to boolean values this parsing is also valid if a and b are integral and c is boolean.
  To avoid this ambiguity and to avoid a situation where the grammar depends on the types of terms,
  ACSL adopts the rule that expressions of the form \lstinline|a < b == c| with logic expressions
  are always interpreted as consecutive comparisons, even if they then fail a type-checking test.
  The conventional parsing can always be obtained by using appropriate parentheses.

  To enforce the same interpretation as in C expressions, one may need
  to add extra parentheses: \lstinline|a == b < c| is equivalent
  to \lstinline|a == b && b < c|, whereas
  \lstinline |a == (b < c)| is
  equivalent to \lstinline|\let x = b < c; a == x|.
  This situation raises some issues, as in the example below.


Comparison operators themselves are
predicates when used in predicate position, and boolean functions when
used in term position, resulting in further subtleties.
\begin{example}
\input{example-lt-modern.tex}
\end{example}

\subsection{Operators precedence}

The precedence of C operators is conservatively extended with
additional operators, as shown in Figure~\ref{fig:precedence}. In this
table, operators are sorted from highest to lowest priority. Operators
of same priority are presented on the same line.


\begin{figure}[t]
  \begin{center}
    \begin{tabular}{|l|l|l|}
      \hline
      class 	& associativity & operators \\
      \hline
      selection & left & \lstinline|[$\cdots$]| \lstinline|->| \lstinline|.| \\
      unary 	& right & \lstinline|!| \lstinline|~| \lstinline|+|
      \lstinline|-| \lstinline|*| \lstinline|&| \lstinline|(cast)|
      \lstinline|sizeof| \\
      multiplicative & left & \lstinline|*| \lstinline|/|  \lstinline|%| \\
      additive & left & \lstinline|+| \lstinline|-| \\
      shift 	& left & \lstinline|<<| \lstinline|>>| \\
      comparison & - & \lstinline|<| \lstinline|<=| \lstinline|>| \lstinline|>=| \\
      comparison & - & \lstinline|==| \lstinline|!=| \\
      bitwise and & left & \lstinline|&| \\
      list repetition & left & \lstinline|*^| \\
      bitwise xor/list concatenation & left & \lstinline|^| \\
      bitwise or & left & \lstinline+|+ \\
      bitwise implies & right & \lstinline+-->+ \\
      bitwise equiv & left & \lstinline+<-->+ \\
      connective and & left & \lstinline|&&| \\
      connective xor & left & \lstinline+^^+ \\
      connective or & left & \lstinline+||+ \\
      connective implies & right & \lstinline|==>| \\
      connective equiv & left & \lstinline|<==>| \\
      ternary connective & right & \lstinline|$\cdots$?$\cdots$:$\cdots$| \\
      binding & left & \Forall{} \Exists{} \Let{} \\
      naming & right & \lstinline|:| \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Operator precedence}
\label{fig:precedence}
\end{figure}

\paragraph{Conditional expressions and labels}
There is a remaining ambiguity between the connective
\lstinline|$\cdots$?$\cdots$:$\cdots$| and the labelling operator
\lstinline|:|. Consider for instance the
expression \lstinline|x?y:z:t|. The precedence table does not indicate
whether this should be understood as \lstinline|x?(y:z):t| or
\lstinline|x?y:(z:t)|.
Such a case must be considered as a syntax error, and should be fixed
by explicitly adding parentheses.

\paragraph{Labels and parsing}
Note also that the use of labels can subtly change the parsing of an
expression, because labeled expressions have the least binding precedence.
That is, once a label is seen, the parser finds the longest valid term or
predicate following the label to consider as the labeled expression.
For example, \lstinline|a && b ==> c && d| parses as 
\lstinline|(a && b) ==> (c && d)|, but
\lstinline|a && nm: b ==> c && d| parses as
\lstinline|a && (nm: ( b ==> (c && d)))|.
Use parentheses liberally to avoid confusing yourself or code readers.

\subsection{Semantics}
\label{sec:twovaluedlogic}

The semantics of logic expressions in ACSL is based on
mathematical first-order
logic~\cite{wikipedia-fo-logic}. In
particular, it is a 2-valued logic with only total functions. Consequently,
expressions are never ``undefined''.
This is an important design choice and the specification writer should
be aware of that. (For a discussion about the issues raised by such
design choices, in similar specification languages such as JML, see
the comprehensive list compiled by Patrice
Chalin~\cite{chalin05ftfjp,chalin07icse}.)

Having only total functions implies than one can write
terms such as \lstinline|1/0|, or \lstinline|*p| when \lstinline!p! is
null (or more
generally
when it points to a non-properly allocated memory cell). In
particular, the predicates
\begin{tabular}{rcl}
  \lstinline!1/0! &\lstinline|==|& \lstinline!1/0! \\\relax
  \lstinline!*p! &\lstinline|==|& \lstinline!*p!
\end{tabular}
are valid, since they are instances of the axiom $\forall x,
x=x$ of first-order logic. The reader should not be alarmed, because
there is no way to deduce anything useful from such terms.
As usual, it is up to the specification designer to write
consistent assertions. For example, when introducing the following lemma
(see Section~\ref{sec:logicspec}):
\listinginput{1}{div_lemma.c}
a premise is added to require \lstinline|y| to be non zero.


\subsection{Typing}\label{sec:typing}

The language of logic expressions is typed (as in \emph{multi-sorted}
first-order logic). Types are either C types or \emph{logic types}
defined as follows:
\begin{itemize}
\item ``mathematical'' types: \lstinline|integer|\indextt{integer} for
  unbounded, mathematical integers, \lstinline|real|\indextt{real} for
  real numbers, \lstinline|boolean|\indextt{boolean} for booleans (with
  values written \lstinline|\true|\indexttbs{true} and
  \lstinline|\false|\indexttbs{false});
\item logic types introduced by the specification writer (see
  Section~\ref{sec:logicspec}).
\end{itemize}
There are implicit coercions for numeric types:
\begin{itemize}
\item C integral types \lstinline|char|, \lstinline|short|, \lstinline|int| and
  \lstinline|long|, signed or unsigned, are all subtypes of type
\lstinline|integer|;
\item \lstinline|integer| is itself a subtype of type \lstinline|real|;
\item C types \lstinline|float| and \lstinline|double| are subtypes of
  type \lstinline|real|.
\end{itemize}
Notes:
\begin{itemize}
\item There is a distinction between booleans and predicates. The
  expression \lstinline|x<y| in term position is a boolean, and the
  same expression
  is also allowed in predicate position.
  \ifCPP{In \NAME, the programming language type \textbf{boolean} and the logic type \lstinline|boolean| are the same type.}
\item Unlike in C, in \NAME there is a distinction between booleans and
  integers. There is an implicit promotion from integers to booleans,
  thus one may write \lstinline|x && y| instead of \lstinline|x != 0 && y != 0|.
  If the reverse conversion is needed, an explicit cast\index{cast} is
  required, \emph{e.g.} \lstinline|(int)(x>0)+1|, where
  \lstinline|\false| becomes 0
  and \lstinline|\true| becomes 1.
\ifCPP{
\item
\lang defines the type \lstinline|bool|. \lstinline|bool| is the programming
language counterpart to the specification language \lstinline|boolean|. 
\lang does distinguish \lstinline|bool| and integral types, but 
like C, does permit implicit conversions from numeric and pointer types to \lstinline|bool|.}
\item Quantification can be made over any type: logic types and C
  types. Quantification over pointers must be used carefully,
  since it depends on the memory state where dereferencing is done (see
  Section~\ref{sec:quantification} and
  Section~\ref{sec:logicalstates}).
\end{itemize}

Formal typing rules for terms are given in appendix~\ref{sec:typingrules}.
	
\subsection{Integer arithmetic and machine integers}

The following integer arithmetic operations apply to
\emph{mathematical integers}: addition, subtraction, multiplication,
unary minus. The value of a C variable of an integral type is promoted
to a mathematical integer. As a consequence, there is no
``arithmetic overflow'' in logic expressions.

Division and modulo are also mathematical operations, which coincide
with the corresponding C operations on C machine integers, thus
following the ISO C99 conventions. In particular, these are not the
usual mathematical Euclidean division and remainder.
C division
rounds the result towards zero. The results are not specified if the
divisor is zero; otherwise if $q$ and $r$ are the quotient and the
remainder of $n$ divided by $d$ then:
\begin{itemize}
\item $|d\times q| \leq |n|$, and $|q|$ is maximal for this property;
\item $q$ is zero if $|n|<|d|$;
\item $q$ is positive if $|n|\geq|d|$ and $n$ and $d$ have the same sign;
\item $q$ is negative if $|n|\geq|d|$ and $n$ and $d$ have opposite signs;
\item $q\times d+r = n$;
\item $|r|<|d|$;
\item $r$ is zero or has the same sign as $n$.
\end{itemize}

\begin{example}
  The following examples illustrate the results of division and modulo
  depending on the sign of their arguments:
  \begin{itemize}
  \item \lstinline|5/3| is 1 and \lstinline|5%3| is 2;
  \item \lstinline|(-5)/3| is -1 and \lstinline|(-5)%3| is -2;
  \item \lstinline|5/(-3)| is -1 and \lstinline|5%(-3)| is 2;
  \item \lstinline|(-5)/(-3)| is 1 and \lstinline|(-5)%(-3)| is -2.
  \end{itemize}
\end{example}

\subsubsection{Hexadecimal octal and binary constants}

Hexadecimal, octal and binary constants are always non-negative. Suffixes
\texttt{u} and \texttt{l} for C constants are allowed but meaningless.

\subsubsection{Casts and  overflows}\index{cast}

In logic expressions, casting from mathematical integers
to an integral C type \lstinline|t| (such as \lstinline|char|,
\lstinline|short|, \lstinline|int|, etc.) is allowed and is
interpreted as follows: the result is the unique value of the
corresponding type that is congruent to the mathematical result modulo
the cardinal of this type, that is $2^{8\times\sizeof(t)}$.
\begin{example}
  \lstinline|(unsigned char)1000| is $1000 \bmod 256$, i.e., $232$;
  however, \lstinline|(signed char)1000| is $((1000+128) \bmod 256) - 128$, i.e., $-24$.
\end{example}

To express in the logic the value of a C
expression, one has to add all the necessary casts. For
example, the logic expression denoting the value of the C expression
\lstinline|x*y+z| is \lstinline|(int)((int)(x*y)+z)|.
Note that there is no implicit cast from integers to C integral types.
\input{integer-cast-modern}

\subsubsection{Quantification on C integral types}
\label{sec:quantification}

Quantification over a C integral type corresponds to integer
quantification over the corresponding interval.
\begin{example}
Thus the formula
\begin{listing-nonumber}
\forall char c; c <= 1000
\end{listing-nonumber}
is equivalent to
\begin{listing-nonumber}
\forall integer c; CHAR_MIN <= c <= CHAR_MAX ==> c <= 1000
\end{listing-nonumber}
where the bounds \verb|CHAR_MIN| and \verb|CHAR_MAX| are defined
in \verb|limits.h|
\end{example}


\subsubsection{Size of C integer types}

The size of C types is architecture-dependent. ACSL does
not enforce these sizes either, hence the semantics of terms involving
such types is also architecture-dependent. The
\lstinline|sizeof|\indextt{sizeof} operator may be used in annotations and is
consistent with its C counterpart (including that its return type 
is a value of type \lstinline|size_t|, and in most cases a constant). 
For instance, it should be
possible to verify the following code:

\listinginput{1}{sizeof.c}

Constants giving maximum and minimum values of those types may be
provided in a library.


\subsubsection{Enum types}

Enum types are also interpreted as mathematical integers. Casting\index{cast}
an integer into an enum in the logic gives the same result as
if the cast was performed in the C code.
\ifCPP{Enum types for \lang{} are discussed in \S\ref{sec:enums}.}


\subsubsection{Bitwise operations}

Like arithmetic operations, bitwise operations apply to any
mathematical integer: any mathematical integer has a unique infinite
2-complement binary representation with infinitely many zeros (for
non-negative numbers) or ones (for negative numbers) on the left.
Bitwise operations apply to this representation.
\begin{example} ~
  \begin{itemize}
  \item \lstinline|7 & 12 == $\cdots$00111 & $\cdots$001100 == $\cdots$00100 == 4|
  \item \lstinline+-8 | 5 == $\cdots$11000 | $\cdots$00101 == $\cdots$11101 == -3+
  \item \lstinline+~5 == ~$\cdots 00101$ == $\cdots$111010 == -6+
  \item \lstinline+-5 << 2 == $\cdots$11011 << 2 == $\cdots$11101100 == -20+
  \item \lstinline+5 >> 2 == $\cdots$00101 >> 2 == $\cdots$0001 == 1+
  \item \lstinline+-5 >> 2 == $\cdots$11011 >> 2 == $\cdots$1110 == -2+
  \end{itemize}
\end{example}

\subsection{Real numbers and floating point numbers}
\label{sec:floating-point}

Floating-point constants and operations are interpreted as
mathematical real numbers: a C variable of type float or double is
implicitly promoted to a real. Integers are promoted to reals if
necessary. The usual binary operations are interpreted as operators on
real numbers, hence they never involve any rounding or overflow.

\begin{example}
  In an annotation, \lstinline|1e+300 * 1e+300| is equal to
  \lstinline|1e+600|, even if that last number exceeds the largest
  representable number in double precision: there is no "overflow".

  $2 * 0.1$ is equal to the real number $0.2$, and not to any 
  floating-point approximation: there is no "rounding".
\end{example}
Unlike the promotion of C integer types to mathematical integers,
there are special float values that do not naturally map to a real
number, namely the IEEE-754 special values for ``not-a-number'',
$+\infty$ and $-\infty$. See below for a detailed discussion on such
special values. However, remember that ACSL's logic has only total
functions. Thus, there are implicit promotion functions
\lstinline|real_of_float|\indextt{real\_of\_float} and
\lstinline|real_of_double|\indextt{real\_of\_double} whose results on
the 3 values above is left unspecified.

In logic, real literals can also be expressed under the hexadecimal
form of C99: \texttt{0x$hh$.$hh$p$\pm{}dd$} where $h$ are hexadecimal
digits and $dd$ is in decimal, denotes number $hh.hh\times
2^{dd}$, e.g. \texttt{0x1.Fp-4} is $(1+15/16)\times 2^{-4}$.


The usual operators for comparison are also interpreted as real operators. 
In particular, the equality operation $\equiv$ for float (or double)
expressions means equality of the real numbers they represent. Or equivalently, $x \equiv y$ for two float
variables $x,y$ means \lstinline|real_of_float(x) $\equiv$ real_of_float(y)|
with the mathematical equality of real
numbers.


Special predicates are also available to express the comparison
operators of float (resp. double) numbers as in C:
\lstinline|\eq_float|\indexttbs{eq\_float}\indexttbs{eq\_double},
\lstinline|\gt_float|\indexttbs{gt\_float}\indexttbs{gt\_double},
\lstinline|\ge_float|\indexttbs{ge\_float}\indexttbs{ge\_double},
\lstinline|\le_float|\indexttbs{le\_float}\indexttbs{le\_double},
\lstinline|\lt_float|\indexttbs{lt\_float}\indexttbs{lt\_double},
\lstinline|\ne_float|\indexttbs{ne\_float}\indexttbs{ne\_double}
(resp. for double).



\subsubsection{Casts, infinity and NaNs}

Casting\index{cast} from a C integer type or a float type to a float
or a double is as in C: the same conversion operations apply.

Conversion of real numbers to float or double values depends on
various possible rounding modes defined by the IEEE~754
standard~\cite{float-std,wikipedia-float}. These modes are defined by
a logic type (see section~\ref{sec:concrete-logic-types}):
\begin{listing-nonumber}
/*@ type rounding_mode = \Up | \Down | \ToZero | \NearestAway | \NearestEven;
*/
\end{listing-nonumber}
Then rounding a real number can be done explicitly using functions
\begin{listing-nonumber}
  logic float \round_float`\indexttbs{round\_float}`(rounding_mode m, real x);
  logic double \round_double`\indexttbs{round\_double}`(rounding_mode m, real x);
\end{listing-nonumber}
Cast operators \lstinline|(float)| and \lstinline|(double)| applied to a
mathematical integer or real number $x$ are equivalent to applying the
rounding functions above with the nearest-even rounding mode (which is
the default rounding mode in C programs).
%(see IEEE 754 norm), which is the closest to $x$ real number
%which is representable in the float (resp. double) type.
If the source real number is too large, this may also result in one
of the special values +infinity and -infinity.
\begin{example}
  We have
  \lstinline|(float)0.1| $\equiv 13421773 \times 2 ^{-27}$ which is equal to
  $0.100000001490116119384765625$
\end{example}
Notice also that unlike for integers, suffixes \lstinline|f| and
\lstinline|l| are
meaningful, because they implicitly add a cast operator as above.

This semantics of casts ensures that the float result \lstinline|r| of
a C operation \lstinline|$e_1$ op $e_2$| on floats, if there is no
overflow and if the default
rounding mode is not changed in the program, has the same real value
as the logic expression \lstinline|(float)($e_1$ op $e_2$)|. Notice
that this is not
true for the equality \lstinline|\eq_float| of floats: \lstinline|-0.0 + -0.0|
in C is equal to the float number \lstinline|-0.0|, which is not
\lstinline|\eq_float| to \lstinline|0.0|, which is the value of the logic
expression \lstinline|(float)(-0.0 + -0.0)|.

Finally, additional predicates are provided that check that their argument
is a finite number, an infinite one, or a NaN:
\begin{listing}{1}
predicate \is_finite`\indexttbs{is\_finite}`(double x); // is a finite double
predicate \is_plus_infinity`\indexttbs{is\_plus\_infinity}`(double x); // is equal to +infinity
predicate \is_minus_infinity`\indexttbs{is\_minus\_infinity}`(double x); // is equal to -infinity
predicate \is_infinite`\indexttbs{is\_infinite}`(double x); // is equal to +infinity or -infinity
predicate \is_NaN`\indexttbs{is\_NaN}`(double x); // is a NaN double
\end{listing}
\lstinline|\is_finite|, \lstinline|\is_plus_infinity|,
\lstinline|\is_minus_infinity| and \lstinline|\is_NaN| are mutually
exclusive predicates.
All these predicates also exist for the \lstinline|float| type.

Recall that under IEEE754 rules, any comparison between two NaN values returns a false value. 
Consequently if a \lstinline|double| variable \lstinline|d| is a  
NaN value, then the C expression \lstinline|d == d| and the logic expression \lstinline|\eq_double(d,d)| will both be 
false, the logic expression \lstinline|\real_of_double(d)| will be undefined,
but the logic expression 
\lstinline|\real_of_double(d) == \real_of_double(d)| is true, as a specific instance of the axiom \lstinline|x $\equiv$ x|.
\subsubsection{Sign}

The sign of a non-NaN floating-point  can be extracted by
the function \lstinline|\sign|\indexttbs{sign}:
\begin{listing}{1}
/*@
 type sign = \Positive | \Negative;

 logic sign \sign(float x);
 logic sign \sign(double x);
*/
\end{listing}


\subsubsection{Quantification}

Quantification over a variable of type \lstinline|real| is of course the usual
quantification over real numbers.

Quantification over float (resp. double) types is allowed as well, and is
supposed to range over all finite real numbers representable as floats (resp.
doubles). In particular, this does not include NaN, +infinity and
-infinity in the considered range.


\subsubsection{Mathematical functions}

Classical mathematical operations like exponential, sine, cosine, and
such are built-in to ACSL. These are listed in Appendix \S\ref{sec:builtins}.
The symbol \lstinline|\pi| refers to the real number $\pi$ and \lstinline|\e| to
the base of the natural logarithm: \lstinline|\log(\e)==1| and \lstinline|\exp(1)==\e|.

\subsubsection{Exact computations}

In order to specify properties of rounding errors, it is useful to express
something about the so-called \emph{exact}
computations~\cite{BoldoFilliatre07}: the computations that would be performed
in an ideal mode where variables denote true real numbers.

To express such exact computations, two special
constructs exist in annotations:
\begin{itemize}
\item $\verb|\exact|(x)$ denotes the value of the C variable $x$ (or
  more generally any C left-value) as if the program were executed with
  ideal real numbers.
\item $\verb|\round_error|(x)$ is a shortcut for $|x-\verb|\exact|(x)|$
\end{itemize}

\begin{example}
Here is an example of a naive approximation of cosine~\cite{ayad09}.
\begin{listing-nonumber}
/*@ requires \abs(\exact(x)) <= 0x1p-5;
  @ requires \round_error(x) <= 0x1p-20;
  @ ensures \abs(\exact(\result) - \cos(\exact(x))) <= 0x1p-24;
  @ ensures \round_error(\result) <= \round_error(x) + 0x3p-24;
  @*/
float cosine(float x) {
  return 1.0f - x * x * 0.5f;
}
\end{listing-nonumber}
\end{example}

\subsection{C arrays and pointers}
\label{sec:pointer}

\subsubsection{Address operator, array access, pointer arithmetic and dereferencing}
\label{sec:address}

These operators are similar to their corresponding C operators.

\emph{address-of} operator should be used with caution.
Values in logic do not lie in C memory so it does not mean
anything to talk about their ``address''.

Unlike in C, 
there is no implicit cast from an array type to a pointer type.
Nevertheless, arithmetic and dereferencing over arrays lying in C memory are 
allowed like in C.

\begin{example}
Dereferencing a C array is equivalent to an access 
to the first element of the array~;
shifting it from $i$ denotes the address of its $i^{th}$ element.
\begin{listing-nonumber}
int tab[10] = { 1 } ;
int x ;
int *p = &x;

//@ requires p == &x
int main(void){
  //@ assert tab[0]==1 && *p == x;
  //@ assert *tab == 1;
  int *q = &tab[3];
  //@ assert q+1 == tab+4;
  ...
}
\end{listing-nonumber}
\end{example}

Since pointers can only refer to values lying in C memory,
\lstinline|p->s| is always equivalent to \lstinline|(*p).s|.
On the contrary, \lstinline|t[i]| is not always equivalent to 
\lstinline|*(t+i)|, especially for arrays not lying in C memory. 
Section~\ref{sec:aggregate} details the use of arrays as logic values. There
are also differences between \lstinline|t| and the pointer to its first element
when evaluating an expression at a given program point. See 
Section~\ref{sec:at} for more information.

\subsubsection{Function pointers}

Pointers to C functions are allowed in logic. The only possible use of
them is to check for equality.

\begin{example}
~
\begin{listing-nonumber}
int f(int x);
int g(int x);

//@ requires p == &f || p == &g;
void h(int(*p)(int)) {
...
}
\end{listing-nonumber}
\end{example}

\subsection{Structures, Unions and Arrays in logic}
\label{sec:aggregate}

Aggregate C objects (i.e. structures, unions and arrays) are also
possible values for terms in logic. 
They can be passed as parameters to and
 returned from logic functions, tested for equality, etc. like any
other values.

Aggregate types can be declared in logic,
\notimplemented{and their contents may be
any logic types themselves}. Constructing such values in logic can be
performed using a syntax similar to C designated initializers.

\begin{example}
Array types in logic may be declared either with or without an
explicit non-negative length. The term \lstinline|\length|
denotes the length of a logic array.

\begin{listing-nonumber}
//@ type point = struct { real x; real y; };
//@ type triangle = point[3];

//@ logic point origin = { .x = 0.0 , .y = 0.0 };
/*@ logic triangle t_iso = { [0] = origin,
  @                          [1] = { .y = 2.0 , .x = 0.0 }
  @                          [2] = { .x = 2.0 , .y = 0.0 }};
  @*/

/*@ logic point centroid(triangle t) = {
  @    .x = mean3(t[0].x,t[1].x,t[2].x);
  @    .y = mean3(t[0].y,t[1].y,t[2].y);
  @ };
  @*/

//@ type polygon = point[];
/*@ logic perimeter(polygon p) =
  @   \sum(0,\length(p)-1,\lambda integer i;d(p[i],p[(i+1) % \length(p)])) ;
  @*/
\end{listing-nonumber}
Beware that because of the principle of only total functions in logic,
t[i] can appear in ACSL annotations even if i is outside the array bounds.

\end{example}

\subsubsection{Functional updates}

Syntax for functional update is similar to initialization of aggregate objects.
\begin{example}
Functional update of an array is done by
\begin{listing-nonumber}
{ t_iso \with [0] = { .x = 3.0, .y = 3.0 } }
\end{listing-nonumber}

Functional update of a structure is done by
\begin{listing-nonumber}
{ origin \with .x = 3.0 }
\end{listing-nonumber}

There is no particular syntax for functional update of a union.
For an \lstinline|object| of a union type, the following equality is not true 
\begin{listing-nonumber}
{ { object \with .x = 3.0 }
           \with .y = 2.0 } == { { object \with .y = 2.0 }
                                          \with .x = 3.0 }
\end{listing-nonumber}

\end{example}

The equality predicate \lstinline|==| applies to aggregate values, but it
is required that they have the same type. Then equality amounts to
recursively checking equality of fields.  Equality of arrays of different
lengths returns false.  Beware that equality of unions is also
equality of all fields.


\subsubsection{C aggregate types}

C aggregate types (struct, union or array) naturally map to logic
types, by recursively mapping their fields.

\begin{example}
There is no implicit cast to type of the updated/initialized fields.
\begin{listing-nonumber}
struct S { int x; float y; int t[10]; };

//@ logic integer f(struct S s) = s.t[3];
//@ logic struct S g(integer n, struct S s) = { s \with .x = (int)n };
\end{listing-nonumber}
Unlike in C, all fields should be initialized:
\begin{listing-nonumber}
/*@ logic struct S h(integer n, int a[10]) = {
  @   .x = (int)n, .y = (float)0.0, .t = a
  @   };
  @*/
\end{listing-nonumber}
\end{example}

\subsubsection{Cast and conversion}

Unlike in C, there is no implicit conversion from an array type to a
pointer type. On the other hand, there is an implicit conversion from
an array of a given size to an array with unspecified size (but not
the converse).

\begin{example}
~
\begin{listing-nonumber}
//@ logic point square[4] = { origin, ... };

//@ ... perimeter(square);          // well-typed
//@ ... centroid(square);           // wrongly typed
//@ ... centroid((triangle)square); // well-typed (truncation)
\end{listing-nonumber}
\end{example}

An explicit cast from an array type to a pointer type is allowed only
for arrays that lie in C memory. As in C, the result of the cast is
the address of the first element of the array (see
Section~\ref{sec:address}).

Conversely, an explicit cast from a pointer type to an array type
acts as collecting the values it points to.

Subtyping and cast recursively apply to fields.

\begin{example}
~
\begin{listing-nonumber}
  struct { float u,v; } p[10];

  //@ assert centroid((point[3])p) == ...

  //@ assert perimeter((point[])p) == ...
\end{listing-nonumber}
\end{example}

Precisely, conversion of a pointer $p$ of type $\tau*$ to a logic array of type
$\tau[]$ returns a logic array $t$ such that
\[
\lstinline|length|(t) = (
\blocklength\indexttbs{block\_length}
(p) - 
\lstinline|\offset|
(p))/\lstinline|sizeof|(\tau)
\]

More generally, an explicit cast from a C aggregate of type $\tau$ to another C 
aggregate type is allowed in order to specify such a value conversion into logical functions or function contracts without using the addressing operator \lstinline|&|.

\begin{example}
Unlike in C, conversion of an aggregate of C type \lstinline|struct| $\tau$  to another structure type is allowed.

\begin{listing-nonumber}
  struct long_st { int x1,y2;};
  struct st { char x,y; };
  
  //@ ensures \result == (struct st) s;
  struct st from_long_st(struct long_st s) {
     return *(struct st *)&s;
  }
\end{listing-nonumber}
\end{example}

\ifCPPinput{cpp-literals}

\section{Function contracts}
\label{sec:fn-behavior}
\index{function contract}\index{contract}

\begin{figure}[t]
  \begin{cadre}
      \input{fn_behavior.bnf}
   \end{cadre}
    \caption{Grammar of function contracts}
  \label{fig:gram:contracts}
\end{figure}

\begin{figure}[t]
  \begin{cadre}
      \input{oldandresult.bnf}
    \end{cadre}
    \caption{\protect\old and \protect\result in terms}
  \label{fig:gram:oldandresult}
\end{figure}

Figure~\ref{fig:gram:contracts} shows a grammar for function
contracts. \textsl{Location} denotes a memory location and is defined
in Section~\ref{sec:locations}. 
% [Patrick B.] START proposition:
\textsl{Allocation-clauses} allow specifying which memory locations 
are dynamically allocated or deallocated by the function from the \textsl{heap}; 
they are defined later in Section~\ref{sec:allocation-clause}.
% END proposition

This section is organized as follows.  First, the grammar for terms is
extended with two new constructs.  Then
Section~\ref{sec:simplecontracts} introduces \emph{simple contracts}.
Finally, Section~\ref{subsec:behaviors} defines more general contracts
involving \emph{named behaviors}. 

The \lstinline|decreases| and
\lstinline|terminates| clauses are presented later in
Section~\ref{sec:termination}.
\textsl{Abrupt-clauses}
allow specifying what happens when the function does not return
normally but exits abruptly; they are defined in
Section~\ref{sec:abrupt-clause}.

The grammar in Fig. \ref{fig:gram:contracts} requires clauses to be written
in a particular order. This order is helpful for readability, though tools may 
be lenient towards out-of-order clauses.

\subsection{Built-in constructs %
  \texorpdfstring{\old}{\textbackslash{}old} %
 and \texorpdfstring{\result}{\textbackslash{}result}}

Post-conditions usually require referring to both the function result and
values in the pre-state. Thus terms are extended with the following new
constructs (shown in Figure~\ref{fig:gram:oldandresult}).
\begin{itemize}
\item \lstinline|\old(e)|\indexttbs{old} denotes the value of
  predicate or term \lstinline|e| in the pre-state of the function.
\item \result\indexttbs{result} denotes the returned value of the function.
\end{itemize}
\lstinline|\old(e)| can be used only in \ensures{}, \assigns{},
\allocates{} and \frees{} clauses, since
the other clauses already refer to only one state, the pre-state.
In addition, \result{} may not be used in the contract of a function that returns
\void{}.

%[Andre M.] START proposition:
%\item in \assigns{} and \frees{} clauses, a \result{} not directly inside an
%  \lstinline|\at(...,Post)| (either explicitly or implicitly) is forbidden.
% Note: we must still be able to write assigns \result \from \nothing, so
% the above must be refined.
% END proposition


C function parameters\index{formal parameter} are obtained by
value from actual parameters that mostly remain unaltered by the
function calls. For that reason, formal parameters in function
contracts are defined such that they always refer implicitly to their
values interpreted in the pre-state.
Thus, the \old construct is not needed (but permitted) for formal parameters (in
function contracts only).

\subsection{Simple function contracts}
\label{sec:simplecontracts}

A simple function contract, having only simple clauses and no named behaviors, takes the following
form:\indextt{requires}\indextt{assigns}\indextt{ensures}
\begin{listing}{1}
/*@ requires P$_1$; requires P$_2$; `\dots`
  @ assigns L$_1$;  assigns L$_2$;  `\dots`
  @ ensures E$_1$;  ensures E$_2$;  `\dots`
  @*/
\end{listing}
The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that it is called in a
  state where the property \lstinline|P$_1$ && P$_2$ && ...| holds.
\item The called function returns\footnote{An \ensures{} clause does not
  imply that the function will necessarily return.} a state where the property
  \lstinline|E$_1$ && E$_2$ && ...| holds.
\item All memory locations that are allocated in both the pre-state and 
  the post-state\footnote{Functions that allocate or free memory can be 
    specified with additional clauses described in
    section~\ref{sec:allocation-clause}.} 
  and do not belong to the
  set \lstinline|L$_1$ $\cup$ L$_2$ $\cup \dots$| are left unchanged in the
  post-state. The set \lstinline|L$_1$ $\cup$ L$_2$ $\cup \dots$| 
  itself is interpreted in the pre-state, although it is permitted to 
  refer to the post state through \lstinline|\at| expressions.
\end{itemize}

Having multiple \lstinline|requires|, \lstinline|assigns|, or 
\lstinline|ensures| clauses only improves 
readability since the contract above is equivalent to the following
simplified one:
\begin{listing}{1}
/*@ requires P$_1$ && P$_2$ && `\dots`;
  @ assigns L$_1$, L$_2$,`\dots`;
  @ ensures E$_1$ && E$_2$ && `\dots`;
  @*/
\end{listing}
If no \requires\ clause is given, it defaults to
\lstinline!\true!, and similarly for an omitted \ensures\ clause.
Giving no \assigns\ clause
means that locations assigned by the function are not specified, so
the caller has no information at all on this function's side
effects. See Section~\ref{sec:multiplecontracts} for more details on
default status of clauses.

\begin{example}
  The following function is given a simple contract for computing
  the integer square root.

  \listinginput{1}{isqrt.c}
%
  The contract means that the function must be called with a
  nonnegative argument, and returns a value satisfying
  the conjunction of the three \ensures{} clauses.
  Inside these \ensures{} clauses, the use of the construct \lstinline|\old(x)|
  is not necessary, even if the function modifies the formal
  parameter\index{formal parameter}
  \lstinline|x|, because function calls modify a copy of the effective parameters,
  and the effective parameters remain unaltered.  In fact, \lstinline|x| denotes
  the effective parameter of \lstinline|isqrt| calls, which has the same value
  interpreted in the pre-state as in the post-state.

\end{example}

\begin{example}
  The following function is given a contract to specify that it increments
  the value pointed to by the pointer given as argument.

  \listinginput{1}{incrstar.c}
%
  The contract means that the function must be called with a pointer
  \lstinline|p| that points to a safely allocated memory location (see
  Section~\ref{sec:pointers} for details on the \valid built-in
  predicate). It does not modify any memory location but the one
  pointed to by \lstinline|p|. Finally, the \ensures clause specifies that
  the value \lstinline!*p! is incremented by one.
\end{example}

\subsection{Semantics of frame conditions}
\label{sec:writesSemantics}
It is worth pointing out that there are different treatments of
frame conditions (assigns statements) in various specification languages.
The frame condition can follow either \emph{writes} semantics or \emph{modifies} semantics.
\begin{itemize}
	\item Under \lstinline|writes| (or assigns) semantics, only those memory locations listed in a frame condition may be \emph{written to}, that is, only those locations may be the target of an assignment statement or listed in the frame condition of a called function. This is true whether or not the value of the memory location changes.
	\item Under \lstinline|modifies| semantics, a memory location may be written to, as long as the value is restored (that is, not modified) by the end of the scope of the function contract. Under this semantics, a frame condition is a requirement on the relationship between two states --- any memory location not a member of the frame condition must have the same value in its pre-state and its post-state.
\end{itemize}
Confusion can arise because the words \emph{assigns} and \emph{modifies} are sometimes used interchangeably. In particular, \textbf{\NAME uses
	\emph{modifies} semantics, even though the frame condition is introduced by the \emph{assigns} keyword}.\footnote{For comparison, JML and the OpenJML tool define frame conditions to have write semantics but use the keywords assigns and modifies interchangeably; however, the KeY tool for JML implements modifies semantics. Ada/SPARK's data flow contracts effectively encode write semantics.}

\subsection{Contracts with named behaviors}
\label{subsec:behaviors}
\index{function behavior}\indextt{behavior}
The general form of a function contract may contain named
behaviors (restricted to two behaviors, in the following, for
readability).
\lstset{firstnumber=auto}
\begin{lstlisting}[style=c,basicstyle=\lp@basic,numbers=left,name=behaviors]
/*@ requires P;
  @ behavior b$_1$:
  @   assumes  A$_1$;
  @   requires R$_1$;
  @   assigns  L$_1$;
  @   ensures  E$_1$;
  @ behavior b$_2$:
  @   assumes  A$_2$;
  @   requires R$_2$;
  @   assigns  L$_2$;
  @   ensures  E$_2$;
  @*/
\end{lstlisting}
The names of behaviors must be distinct within the given function (or statement) contract. A behavior name may be the same as a behavior name 
of an enclosing contract; in this case references to the behavior name 
refer to the behavior in the innermost contract of those contracts in scope.

The semantics of such a contract is as follows:
\begin{itemize}
\item The caller of the function must guarantee that the call is
  performed in a state where the \emph{effective precondition}, namely the property
  \lstinline|P && (A$_1$ ==> R$_1$) && (A$_2$ ==> R$_2$)|, holds.
\item The called function returns a state where
the properties \lstinline|\old(A$_i$) ==> E$_i$| hold for each~$i$.
The conjunction of these properties is the \emph{effective postcondition} of the contract.
\item For each $i$, if the function is called in a pre-state where
  \lstinline|A$_i$| holds, then each memory location of that pre-state 
  that does not belong to the set \lstinline|L$_i$| is left unchanged in 
  the post-state.
% In any case, locations of $L$ are unchanged.
\end{itemize}


\requires{} clauses in the behaviors are proposed
mainly to improve readability (to avoid some duplication of
formulas), since the contract above is equivalent to the following
simplified one:
\begin{listing}{1}
/*@ requires P && (A$_1$ ==> R$_1$) && (A$_2$ ==> R$_2$);
  @ behavior b$_1$:
  @   assumes A$_1$;
  @   assigns L$_1$;
  @   ensures E$_2$;
  @ behavior b$_2$:
  @   assumes A$_2$;
  @   assigns L$_2$;
  @   ensures E$_2$;
  @*/
\end{listing}

A simple contract such as
\begin{listing}{1}
/*@ requires P; assigns L; ensures E; */
\end{listing}
is actually equivalent to a single named behavior as follows:
\begin{listing}{1}
/*@ requires P;
  @ behavior <unique name>:
  @   assumes \true;
  @   assigns L;
  @   ensures E;
  @*/
\end{listing}
Similarly, global \assigns\ and \ensures\ clauses are equivalent to a
single named behavior. More precisely, the following contract
\begin{listing}{1}
/*@ requires P;
  @ assigns L;
  @ ensures E;
  @ behavior b$_1$: `\dots`
  @ behavior b$_2$: `\dots`
  @ `\dots`
  @*/
\end{listing}
is equivalent to (if b$_1$ and b$_2$ do not have requires clauses)
\begin{listing}{1}
/*@ requires P;
  @ behavior <unique name>:
  @   assumes \true;
  @   assigns L;
  @   ensures E;
  @ behavior b$_1$: `\dots`
  @ behavior b$_2$: `\dots`
  @ `\dots`
  @*/
\end{listing}

\begin{example}
\label{ex:bsearch}
In the following, \lstinline|bsearch(t,n,v)| searches for element \lstinline|v|
in array \lstinline|t| between indices \lstinline|0| and \lstinline|n-1|.

\listinginput{1}{bsearch.c}
%
The precondition requires array \lstinline|t| to be allocated at least
from indices \lstinline|0|
to \lstinline|n-1|. The two named behaviors
correspond respectively to the successful behavior and the failing
behavior.

Since the function is performing a binary search, it requires the
array \lstinline|t| to be sorted in increasing order: this is the purpose of
the predicate named \lstinline|t_is_sorted| in the \assumes\ clause of the
behavior named \lstinline|failure|.

See~\ref{sec:loop_annot} for a continuation of this example.
\end{example}

\begin{example}
  The following function illustrates the importance of different
  \assigns{} clauses for each behavior.

  \listinginput{1}{cond_assigns.c}
%
  Its contract means that it may modify values pointed to by
  \lstinline|p| or by \lstinline|q|,
  conditionally on the sign of~\lstinline|n|.
\end{example}


\subsubsection{Completeness of behaviors}
\label{sec:compl-behav}
In a contract with named behaviors, it is not required that
the disjunction of the \lstinline|A$_i$| is true, \emph{i.e.} it is not 
mandatory to provide a ``complete'' set of behaviors.
If such a condition is desired, it is possible to add the following clause
to a contract:
\index{complete behaviors}
\begin{listing-nonumber}
/*@ `\dots`
  @ complete behaviors b$_1$,`\dots`,b$_n$;
  @*/
\end{listing-nonumber}
It specifies that the set of behaviors \lstinline|b$_1$,$\ldots$,b$_n$| 
is complete \emph{i.e.} that
\begin{listing-nonumber}
R ==> (A$_1$ || A$_2$ || ... || A$_n$)
\end{listing-nonumber}
holds, where \lstinline|R| is the precondition of the contract.
The simplified version of that clause
\begin{listing-nonumber}
/*@ `\dots`
  @ complete behaviors;
  @*/
\end{listing-nonumber}
means that all named\footnote{If there is a default (unnamed) behavior, it has an 
	\lstinline|assumes| clause of true; including it makes the 
	completeness assertion trivially true.} behaviors given in the contract should be taken into account.

Similarly, it is not required that two distinct behaviors are disjoint.
If desired, this can be specified with the following clause:
\index{disjoint behaviors}
\begin{listing-nonumber}
/*@ ...
  @ disjoint behaviors b$_1$,`\dots`,b$_n$;
  @*/
\end{listing-nonumber}
It means that the given behaviors are pairwise disjoint \emph{i.e.}
that, for all distinct $i$ and $j$,
\begin{listing-nonumber}
R ==> ! (A$_i$ && A$_j$)
\end{listing-nonumber}
holds.
The simplified version of that clause
\begin{listing-nonumber}
/*@ ...
  @ disjoint behaviors;
  @*/
\end{listing-nonumber}
means that all named\footnote{If there is a default (unnamed) behavior, it has an 
\lstinline|assumes| clause of true and is thus not disjoint with other clauses.} behaviors given in the contract should be taken into account.
Multiple \lstinline|complete| and \lstinline|disjoint| sets of behaviors can
be given for the same contract.

\subsection{Memory locations and sets of values}
\label{sec:locations}\index{location}

There are several places where one needs to describe a set of memory
locations: for example, in \lstinline|assigns| clauses of function contracts and
in \lstinline|loop assigns| clauses (see section~\ref{sec:loop_annot}).
A \emph{memory location} is an
l-value\index{l-value} and a set of memory locations is a \emph{tset}. 
Moreover, the argument of
an \assigns{} clause must be a set of modifiable l-values, as described in
Section~\ref{sec:glossary}. 
More generally, we introduce syntactic constructs to denote \emph{sets of
  values} (tsets) that are also useful for the \separated predicate (see Section~\ref{sec:separated}). The terms in a tset may have any type, though the operations described below are only well-typed for certain types of tsets. For example, \lstinline|s$_1$[s$_2$]| as defined below is only well-typed if one of 
\lstinline|s$_1$| and \lstinline|s$_2$| is a set of arrays and the other a set of integers.

\begin{figure}
  \begin{cadre}
      \input{loc.bnf}
    \end{cadre}
  \caption{Grammar for sets of memory locations}
\label{fig:gram:locations}
\end{figure}

\paragraph{Ranges}
The \lstinline|..| syntax for ranges of integers has the appearance of a
binary operator but is not a binary operator with conventional precedence,
because either or both operand is optional.  
A missing operand designates an
open range, that is the range includes all integers in the negative (if the left operand is missing) or positive direction (if the right operand is missing).
This range syntax is used only within parentheses to designate a set of 
integers (cf. Fig. \ref{fig:gram:locations} later) or within square brackets to designate a 
range of array indices, as shown in Figs.  \ref{fig:gram:term} and 
\ref{fig:gram:locations}.

\paragraph{Tsets}
The grammar for tsets is given in
Figure~\ref{fig:gram:locations}. 
Note though that tsets are actually simply terms whose type is a set. Thus, for example, the + operator is overloaded for various numeric and string types and also for sets.
The constructs in Figure~\ref{fig:gram:locations} are syntactically valid whatever the types of terms are, but are only type-valid when used on values that are tsets as described.\footnote{Resolving the restrictions on tsets during type-checking rather than parsing greatly reduces the size and complexity of the overall grammar and avoids needing to
propagate meta-information along with parsing information.}

The semantics of tset operations is given below,
where $s$ denotes any \textsl{tset}.
\begin{itemize}
\item \lstinline|\empty|\indexttbs{empty} denotes the empty set.
\item a simple term denotes a singleton set.
\item \lstinline|s->id| denotes the set of \lstinline|x->id| for each
  \lstinline|x $\in$ s|.
\item \lstinline|s.id| denotes the set of \lstinline|x.id| for each
  \lstinline|x $\in$ s|.
\item \lstinline|*s| denotes the set of \lstinline|*x| for each
  \lstinline|x $\in$ s|.
\item \lstinline|&s| denotes the set of \lstinline|&x| for each
  \lstinline|x $\in$ s|.
\item \lstinline|s$_1$[s$_2$]| denotes the set of
\lstinline|x$_1$[x$_2$]| for each \lstinline|x$_1$ $\in$ s$_1$|
  and \lstinline|x$_2$ $\in$ s$_2$|.
\item \lstinline|t$_1$ .. t$_2$| denotes the set of integers between 
\lstinline|t$_1$| and \lstinline|t$_2$|, inclusive. 
If \lstinline|t$_1$ $>$ t$_2$|, this is the same as \lstinline+\empty+
\item \lstinline|\union(s$_1$,$\ldots$,s$_n$)|\indexttbs{union}
denotes the union 
of \lstinline|s$_1, $s$_2,\ldots $| and \lstinline|s$_n$|;
\item \lstinline|\inter(s$_1$,$\ldots$,s$_n$)|\indexttbs{inter}
denotes the intersection 
of \lstinline|s$_1, $s$_2,\ldots $| and \lstinline|s$_n$|;
\item \lstinline|s$_1$+s$_2$| denotes the set of
  \lstinline|x$_1$+x$_2$| for each \lstinline|x$_1$ $\in$ s$_1$|
  and \lstinline|x$_2$ $\in$ s$_2$|;
\item \lstinline|{ t$_1$,$\ldots$,t$_n$ }| is the set composed of the
elements \lstinline|t$_1$|, $\ldots$, \lstinline|t$_n$|.
\item \lstinline|(s)| denotes the same set as \lstinline|s|;
\item \lstinline+{ s | b ; P }+ denotes set
  comprehension\index{comprehension},
  that is the union of the sets denoted by \lstinline|s| for each
  value \lstinline|b| of binders
  satisfying predicate \lstinline|P|
  (binders \lstinline|b| are bound in both \lstinline|s| and \lstinline|P|).
\item \lstinline|x \in s| holds if and only if \lstinline|x| is an element of \lstinline|s|.
  The operator has the same precedence as relational predicates (e.g., \lstinline|<|).
\item \lstinline|\subset(s$_1$,s$_2$)| holds if and only if each element
  of \lstinline|s$_1$| is also an element of \lstinline|s$_2$|
  (that is, \lstinline|s$_1$| is a subset of \lstinline|s$_2$|).
\end{itemize}

Note that \lstinline|assigns \nothing| is equivalent to
\lstinline|assigns \empty|; it is left for convenience.

Note that in some cases there is a small ambiguity. The
use of an 
individual variable, as in \lstinline|assigns x;|, invokes an implicit conversion to a singleton set, to 
\lstinline|assigns {x};|, but only if the value of \lstinline|x| is not already a set of memory locations.
Similarly, for example, if \lstinline|x| is a set of memory locations but \lstinline|y| is not a set, then \lstinline|assigns x,y;| means
\lstinline|assigns \union(x,{y});|. If neither \lstinline|x| and \lstinline|y| are sets, then \lstinline|assigns x,y;| means
\lstinline|assigns \union({x},{y});|. 

\begin{example}
  The following function sets each cell of an array to 0.

  \listinginput{1}{assigns_array.c}
%
  It is annotated with three equivalent \assigns{} clauses, each one
  specifying that only the set of cells
  \lstinline|{t[0],$\ldots$,t[n-1]}|
  is potentially modified.
\end{example}

\begin{example}
  \label{ex:locations-list}
  The following function increments each value stored in a linked
  list.

  \listinginput{1}{assigns_list.c}
%
  The \assigns{} clause specifies that the set of possibly modified memory
  locations is the set of fields \lstinline|q->hd| for each pointer
  \lstinline|q|
  reachable from \lstinline|p| following \lstinline|next| fields. See
  Section~\ref{sec:inductivepredicates} for details about the
  declaration of the predicate \texttt{reachable}.
\end{example}

\subsection{Default contracts, multiple contracts}
\label{sec:multiplecontracts}

A C function can be defined only once but declared several times.
It is allowed to annotate each of these declarations with contracts.
Those contracts are seen as a single contract with the union of the
\requires\ clauses and behaviors.

On the other hand, a function may have no contract at all, or a
contract with missing clauses. Missing \lstinline|requires| and
\lstinline|ensures| clauses default to \lstinline!\true!.
If no \lstinline|assigns| clause is given, it remains unspecified. If the
function under consideration has only a declaration but no body, then
it means that it potentially modifies ``everything'', hence in practice
it will be impossible to verify anything about programs calling that
function; in other words giving it a contract is in practice
mandatory. On the other hand, if that function has a body, giving no
\lstinline|assigns| clause means in practice that it is left to tools to
compute an over-approximation of the sets of modified locations.

\review{This rule seems not to be sound. Better would be a single-definition rule -- the same contract must be visible for all uses and implementations of a function. Repetitions of a contract must be token for token identical - encouraging one specification in one .h file. }

\ifCPPinput{cpp-default-values}
	
\section{Statement annotations}
\index{annotation}

Annotations on C statements are of three kinds:
\begin{itemize}
\item \emph{Assert}\index{assertion} statements are allowed before any C statement or
  at end of blocks.
\item\index{annotation!loop}\index{loop!annotation}
  \emph{Loop annotations} (the \invariant, \assigns, and \variant clauses) are allowed
  before any loop statement: \lstinline|while|, \lstinline|for|, and
  \lstinline|do ... while|.
\item\index{statement contract}\index{contract}
  \emph{Statement contracts} are allowed before any C statement (including a block), specifying
  its behavior in a manner similar to function contracts.
\end{itemize}

\subsection{Assertions}
\indextt{assert}
\label{sec:assertions}
\begin{figure}[t]
  \begin{cadre}
    \input{assertions.bnf}
  \end{cadre}
  \caption{Grammar for assertions}
  \label{fig:gram:assertions}
\end{figure}

The syntax of assertions is given in Figure~\ref{fig:gram:assertions},
as an extension of the grammar of C statements.

\begin{itemize}
\item
  \lstinline|assert P|  means that \lstinline|P| must hold in the current state
  (the sequence point where the assertion occurs).

\item The variant \lstinline|for id$_1$,$\ldots$,id$_k$: assert P|
  associates the assertion to the named behaviors \lstinline|id$_i$|, each
  of them being a behavior identifier for the current function (or a
  behavior of an enclosing block as defined later in
  Section~\ref{sec:statement_contract}).  It means that this assertion
  is only required to hold for the listed behaviors.
\item Introducing the assertion with the \lstinline|check| keyword rather than \lstinline|assert| indicates a
  \emph{non-blocking} semantics. In other words, even if the property to be \lstinline|check|ed is found invalid,
  the execution of the program should continue unhindered.
\end{itemize}

\subsection{Loop annotations}
\label{sec:loop_annot}

\begin{figure}[t]
  \begin{cadre}
    \input{loops.bnf}
  \end{cadre}
  \caption{Grammar for loop annotations}
  \label{fig:gram:loops}
\end{figure}

The syntax of loop annotations is given in Figure~\ref{fig:gram:loops},
as an extension of the grammar of C statements.
\textsl{Loop-allocation} clauses allow specifying which memory locations 
are dynamically allocated or deallocated by a loop from the \textsl{heap}; 
they are defined later in Section~\ref{sec:allocation-clause}.

\subsubsection{Loop invariants and loop assigns}
\label{sec:loop-invariants}
\index{invariant!loop}\index{loop!invariant}\index{loop!assigns}
The semantics of loop invariants and loop assigns is defined as follows: 
a simple loop annotation of the form
\begin{listing}{1}
/*@ loop invariant I;
  @ loop assigns L;
  @*/
...
\end{listing}
specifies that the following conditions hold.
\begin{itemize}
\item The predicate \lstinline|I| holds before entering the loop
  (in the case of a
  \lstinline|for| loop, this means right after the initialization expression).
\item The predicate \lstinline|I| is an inductive invariant, that is
  if \lstinline|I| is assumed true in some state where the condition
  \lstinline|c| is also true, and if execution of the loop body in
  that state ends normally at the end of the body or with a
  \Continue statement, \lstinline|I| is true in the
  resulting state. 
  If the loop condition has side effects, these are
  included in the loop body in a suitable way:
  \begin{itemize}
  \item for a \lstinline|while (c) s| loop, \lstinline|I| must be
    preserved by the side-effects of \lstinline|c| followed by
    \lstinline|s|;
  \item for a \lstinline|for(init;c;step) s| loop, \lstinline|I| must
    be preserved by the side-effects of \lstinline|c| followed by
    \lstinline|s| followed by \lstinline|step|;
  \item for a \lstinline|do s while (c);| loop, \lstinline|I| must be
    preserved by \lstinline|s| followed by the side-effects of
    \lstinline|c|.
  \end{itemize}
Note that if \lstinline|c| has side-effects, the invariant might not
be true at the exit of the loop: the last ``step'' starts from a state
where \lstinline|I| holds, performs the side-effects of \lstinline|c|,
which in the end evaluates to false and exits the loop. Likewise, if a
loop is exited through a \Break statement, \lstinline|I|
does not necessarily hold, as side effects may occur between
the last state in which \lstinline|I| was supposed to hold and 
the \Break statement.

\item At any loop iteration, any location that was allocated before
  entering the loop and is not a member of \lstinline|L| (interpreted in the
  current state, that is \lstinline|LoopCurrent|) has the same value as
  before entering the loop (\lstinline|LoopEntry|).
  In fact, the \Loop \assigns clause specifies an inductive
  invariant for the locations that are not members of \lstinline|L|.
\end{itemize}

\subsubsection{Loop behaviors}
\index{loop!behavior}
A loop annotation preceded by
\lstinline|for id_1,$\ldots$,id_k:| is similar to the above, but
applies only for behaviors \lstinline|id_1|,$\ldots$,\lstinline|id_k|
of the current function, 
hence in particular holds only under the assumption of their \assumes
clauses.


\paragraph{Remarks}
\begin{itemize}
\item The \old{} construct is not allowed
  in loop annotations. The \lstinline|\at| form should be used to
  refer to another state (see Section~\ref{sec:at}).
\item When a loop exits with \lstinline{break} or \lstinline{return} or
  \lstinline{goto}, it is not required that the loop invariant holds.
  In such cases, locations that are not members of $L$ can be
  assigned between the end of the previous iteration and the exit statement.
\item If no \lstinline{loop assigns}
  clause is given, assignments remain unspecified.
  It is left to tools to compute an over-approximation of the sets
  of assigned locations.
\end{itemize}

\begin{example}
\label{ex:bsearch2}
Here is a continuation of example~\ref{ex:bsearch}. Note the use of
a loop invariant associated to a function behavior.

\listinginput{1}{bsearch2.c}

\end{example}

\subsubsection{Loop variants}\label{sec:loop-variant}
\indextt{variant}\index{termination}\index{loop!variant}

Optionally, a loop annotation may include a loop variant of the form
\begin{listing-nonumber}
/*@ loop variant m; */
\end{listing-nonumber}
where \lstinline|m| is a term of type \lstinline|integer|.

The semantics is as follows: for each loop iteration that terminates
normally or with \lstinline|continue|, the value of \lstinline|m| at end of the
iteration must be smaller than its value at the beginning of the
iteration. Moreover, its value at the beginning of the iteration
must be nonnegative. Note that the value of \lstinline|m| at loop exit might be
negative. It does not compromise termination of the
loop. Here is an example:

\begin{example}
  \hspace{0pt}
  \label{ex:loopvariant}
  \listinginput{1}{loopvariantnegative.c}
\end{example}

It is also possible to specify termination orderings other than the
usual order on integers, using the additional \lstinline|for|
modifier. This is explained in Section~\ref{sec:termination}.

\subsubsection{General inductive invariants}
\index{invariant}
It is actually allowed to pose an inductive invariant
anywhere inside a loop body.
For example, it makes sense for a
\lstinline|do s while (c);| loop to contain an invariant right after statement
\lstinline|s|. Such an invariant is a kind of assertion, as
shown in Figure~\ref{fig:advancedinvariants}.

\begin{figure}[t]
  \begin{cadre}
    \input{generalinvariants.bnf}
  \end{cadre}
  \caption{Grammar for general inductive invariants}
  \label{fig:advancedinvariants}
\end{figure}

\begin{example}
  In the following example, the natural invariant holds at this point
  (\lstinline!\max! and \lstinline!\lambda! are introduced later in
  Section~\ref{sec:higherorder}).
  It would be less convenient to set an invariant at the beginning
  of the loop.
  \listinginput{1}{dowhile.c}
\end{example}

More generally, loops can be introduced by \lstinline|goto|s.
As a consequence, such invariants may occur anywhere
inside a function's body. The meaning is that the invariant
holds at that point, much like an \lstinline{assert}. Moreover, the
invariant must be inductive, \emph{i.e.} it must be preserved across a
loop iteration. Several invariants are allowed at different places in
a loop body. These extensions are useful when dealing with complex
control flows.

\begin{example}
Here is a program annotated with an invariant inside the loop body:
\listinginput{1}{advancedloopinvariants.c}
The control-flow graph of the code is as follows
\begin{center}
\includegraphics{cfg.mps}
%\begin{tikzpicture}
%\path (0,4) node[fill=yellow,draw](n1){1}
%      (0,2) node[fill=yellow,draw](n2){2};
%\draw[->,very thick] (n1.south) -- (n2.north);
% \filldraw[fill=green!20] ellipse (1cm and 4mm);
% \path (-2,2) node[fill=yellow,draw] (eb) {Expected behavior}
%       (-2,1) node[fill=yellow,draw] (fs) {Formal Specification}
%       (0,0) node (proof) {Proofs}
%       (2,1) node[fill=blue!30,draw] (pm) {Program Model}
%       (2,2) node[fill=blue!30,draw] (prog) {Program};
% \draw[->,very thick] (eb.south) -- (fs.north);
% \draw[->,very thick,shorten >=5mm] (fs.south) -- (proof.north);
% \draw[->,very thick] (prog.south) -- (pm.north);
% \draw[->,very thick,shorten >=5mm] (pm.south) -- (proof.north);
%\end{tikzpicture}
\end{center}
The invariant is inductively preserved by the two paths that go from
node ``inv'' to itself.
\end{example}

\begin{example}
\input{inductiveloopinvariants_modern}
\end{example}

\ifCPPinput{cpp-forrange}

\subsection{Built-in construct \texorpdfstring{\at}{\textbackslash{}at}}
\label{sec:at}
\indexttbs{at} Statement annotations usually need another additional
construct \lstinline|\at(e,id)| referring to the value of the
expression \lstinline|e| in the state at label \lstinline|id|. 
In particular, for a C array of \lstinline|int|, 
\lstinline|t|, \lstinline|\at(t,id)| is a logical
array whose content is the same as that of \lstinline|t| in state at label
\lstinline|id|. It is thus very different from 
\lstinline|\at((int *)t,id)|, which
is a pointer to the first element of \lstinline|t| (and stays the same between 
the state at \lstinline|id| and the current state). Namely, if 
\lstinline|t[0]| has changed since \lstinline|id|, we have
\lstinline|\at(t,id)[0] != \at((int *)t,id)[0]|.

The label \lstinline|id| can be either a regular C label or a label added
within a ghost statement as described in Section~\ref{sec:ghost}. This
label must be declared in the same function as the occurrence of
\lstinline|\at(e,id)|, but unlike \lstinline|goto|s, more restrictive
scoping rules must be respected:
\begin{itemize}
\item the label \lstinline|id| must occur before the occurrence of
\lstinline|\at(e,id)|
  in the source;
\item the label \lstinline|id| must not be inside an inner block that syntactically ends before the use of the label.
\end{itemize}
These rules are exactly the same rules as for the visibility of local
variables within C statements (see~\cite{KR88}, Section A11.1).

Note that the \lstinline|\at| construct must be interpreted carefully when a variable is redeclared within the body of a function.
Consider the example below:
\begin{example}
\label{redeclaration}
\listinginput{1}{redeclaredat.c}
\end{example}
\begin{itemize}
\item The assert annotation on line 8 refers to the value of \lstinline|x| declared on line 1 and set on line 6; it is proved without difficulty.
\item The assert annotation on line 14 refers to the current state of \lstinline|*x|, where \lstinline|x| is declared on line 9, that is the assignment to \lstinline|y| on line 12; it is also proved without difficulty.
\item The assert annotation on line 156 refers to the state of \lstinline|*x| at label \lstinline|c|, that is the assignment to \lstinline|y| on line 5; it is also proved without difficulty.
\end{itemize}
But consider the assert annotation on line 13. It references the state at label b. At that label, \lstinline|x| refers to the declaration on line 1, not the declaration current at line 13, namely the declaration on line 9. 

Thus determining the value of an expression at a given label requires that the name and type resolution of the expression be performed at that label also, and may be different than the results of name and type resolution in the state in which the \lstinline|\at| expression occurs.

\ifCPP{\ifImpl{Status: frama-clang does not yet implement the above in cases where the type of the redeclared variable changes.}}


\subsubsection*{Default logic labels}\label{sec:default-logic-labels}
\indextt{Init}\indextt{Pre}\indextt{Here}\indextt{Old}\indextt{Post}\indextt{LoopEntry}\indextt{LoopCurrent}
There are seven predefined logic labels: \lstinline|Pre|, \lstinline|Here|,
\lstinline|Old|,
\lstinline|Post|, \lstinline|LoopEntry|, \lstinline|LoopCurrent|
and \lstinline|Init|.
\lstinline|\old(e)|\indexttbs{old} is
in fact syntactic sugar for \lstinline|\at(e,Old)|.

\begin{table}
\caption{Meaning and permitted locations of built-in labels}
\label{tab:lables}
\begin{tabular}[t]{|c|p{2.5in}|p{2.5in}|}
\hline
Label & Permitted locations & Meaning \\
\hline
\multirow{3}{*}{Here} & statement annotations & state where the annotation appears \\
                              & function contracts & pre-state of function \\
                              & data invariants & invocation point of the invariant  \\
\hline
\multirow{2}{*}{Old} & function contracts & pre-state of function \\
                             & statement contracts & pre-state of statement \\
\hline
Pre & statement annotations & pre-state of enclosing function \\
\hline
Post & assigns and ensures clauses & post-state of contract \\
\hline
LoopEntry & loop annotations and loop statements & state prior to first loop entry \\
\hline
LoopCurrent & loop annotations and loop statements & state at beginning of current loop interation \\
\hline
Init & all annotations & state before call to main \\
\hline
\end{tabular}
\end{table}

\begin{itemize}

\item The label \lstinline|Here| is visible in all statement annotations,
  where it refers to the state where the annotation appears; and in
  all contracts, where it refers to the pre-state for
  the~\lstinline|requires|, \lstinline|assumes|, \lstinline|assigns|,
  \lstinline|frees|,
  \lstinline|decreases|,
  \lstinline|terminates|
  clauses and the post-state for 
  \lstinline|ensures|, \lstinline|allocates|, and abrupt termination
  clauses.
It is also visible in data invariants, presented in Section~\ref{sec:invariants}.
\item The label \lstinline|Old| is visible in \lstinline|assigns| and
  \lstinline|ensures| clauses of all contracts (both for functions and for
  statement contracts described below in
  Section~\ref{sec:statement_contract}), and refers to the pre-state
  of this contract.
% [Patrick B.] START remarque:
% ``Old'' peut galement s'utiliser dans les clauses relatives aux
% terminaisons abruptes des contrats d'instructions. 
%Ce n'est pas dit ici.
% END remarque
\item The label \lstinline|Pre| is visible in all statement annotations,
  and refers to the pre-state of the function it occurs in.
\item The label \lstinline|Post| is visible in
\lstinline|assigns| and \lstinline|ensures| clauses of all contracts,
and it refers to the post-state.

\item The label \lstinline|LoopEntry|
is visible in loop annotations and
all annotations related to a statement enclosed in a loop.
It refers to the state just before entering that loop
for the first time --but after initialization took place in the case of a 
\lstinline|for| loop, as for \lstinline|loop invariant| 
(section~\ref{sec:loop-invariants}). When \lstinline|LoopEntry| is used in a 
statement enclosed in nested loops, it
refers to the innermost loop containing that statement.

\item The label \lstinline|LoopCurrent|
is visible in loop annotations and
all other annotations related to a statement enclosed in a loop.
It refers to the state at the beginning of the current step of the loop (see
section~\ref{sec:loop-invariants} for more details on what constitutes a loop
step in presence of side-effects in the condition). When
\lstinline|LoopCurrent| is used in a statement enclosed in nested loops, it
refers to the innermost loop containing that statement.

\item The label \lstinline|Init| is visible in all statement annotations and 
contracts. It refers to the state just before the call to the \lstinline|main| 
function, once the global data have been initialized.
\end{itemize}

Inside loop annotations, the labels \lstinline|LoopCurrent| and 
\lstinline|Here| are equivalent,
except inside clauses \lstinline|loop frees|
(see section~\ref{sec:allocation-clause}) 
where \lstinline|Here| is equivalent to \lstinline|LoopEntry|.

There is one special case regarding formal parameters.
Despite any surrounding \lstinline|\at| construct or the 
type of clause, formal
parameters in a function contract are always interpreted
in the pre-state (that is in the \lstinline|Old| state).
Note that formal parameters are not special in this regard in 
statement contracts.

No logic label is visible in global logic declarations
such as lemmas, axioms, definition of predicate or logic
functions. When such an annotation needs to refer to a given memory
state, it has to be given a label binder: this is described in
Section~\ref{sec:logicalstates}.

\begin{figure}[t]
  \begin{cadre}
    \input{at.bnf}
  \end{cadre}
  \caption{Grammar for \lstinline|at| construct}
  \label{fig:gram:at}
\end{figure}


\begin{example}
  The code below implements the famous extended Euclid's algorithm
  for computing the greatest common divisor of two integers $x$ and
  $y$, while computing at the same time the two \emph{B\'ezout coefficients} $p$
  and $q$ such that $p\times x+q\times y = \gcd(x,y)$.
  The loop invariant for the B\'ezout property needs to refer to the
  value of $x$ and $y$ in the pre-state of the function.
  \listinginput{1}{euclide.c}
\end{example}

\begin{example}
  Here is a toy example illustrating tricky issues with \lstinline|\at| and
  labels:

  \listinginput{1}{oldat.c}

  The two \lstinline|ensures| clauses are equivalent. The simpler clause
  \lstinline|t[i] == \old(t[i]) + 1| would be wrong because in
  \lstinline|\old(t[i])|, \lstinline|i| denotes the value of \texttt{i} in the
  pre-state.

  Also, the \lstinline|assigns| clause \lstinline|i,t[i]| would be
  wrong also because again in \lstinline|t[i]|, the value of \texttt{i} is
  its value in the pre-state.

\end{example}

\begin{example}
Here is an example illustrating the use of \lstinline|LoopEntry| and
\lstinline|LoopCurrent|

\listinginput{1}{loop_current.c}
\end{example}

\subsection{Statement contracts}
\label{sec:statement_contract}
\index{statement contract}\index{contract}
\begin{figure}[t]
  \begin{cadre}
    \input{st_contracts.bnf}
  \end{cadre}
  \caption{Grammar for statement contracts}
  \label{fig:gram:stcontracts}
\end{figure}

The grammar for statement contracts is given in
Figure~\ref{fig:gram:stcontracts}. It is similar to function
contracts, but without a \decreases{} clause. Additionally, a statement contract
may refer to enclosing named behaviors, with the form
\lstinline|for id:...|.
Such contracts are only valid for the
corresponding behaviors, in particular only under the
corresponding \assumes{} clause.
Note that behaviors in statement contracts may have the same ids as enclosing function contract behaviors
or enclosing statement contracts.
In such cases, a use of an id (in a \lstinline|for| construct) refers to the innermost behavior id.

%% TODO: Add an example with a \For{}.

% [Patrick B.] START proposition:
The \ensures\indextt{ensures} clause does not constrain the
post-state when the annotated statement is terminated 
by a \lstinline|goto| jumping out of it,
by any abrupt termination of the statement that is annotated.
To specify such behaviors, \textsl{abrupt clauses} (described in
Section~\ref{sec:abrupt-clause}) need to be used.

On the other hand, it is different with \assigns\indextt{assigns} clauses.
The locations having their values modified during the path execution, starting
at the beginning of the annotated statement and leading
to a \lstinline|goto| jumping out of it, should be part of its 
\assigns clause.
%% TODO: Needs of clarification
%% \marginpar{TODO: This behavior of assigns clauses for abrupt exits from statements is different than the corresponding behavior for loops. Should it be? }

\begin{example} The clause \lstinline|assigns \nothing;| does not hold for that statement,
even if the clause \lstinline|ensures x==\old(x);| holds: 
\begin{listing}{1}
/*@ assigns x;
  @ ensures x==\old(x);
  @*/
  if (c) {
    x++;
    goto L;
  }
L: ...
\end{listing}
\end{example}
% END proposition

% [Patrick B.] START proposition:
\textsl{Allocation-clauses} allow specifying which memory locations 
are dynamically allocated or deallocated by the annotated statement from the \textsl{heap}; 
they are defined later in Section~\ref{sec:allocation-clause}.

The semantics of multiple clauses or missing clauses of a given type within a behavior or in the 
unnamed behavior are the same as for function contracts (cf. Section \ref{sec:multiplecontracts}).
% END proposition

\section{Termination}
\label{sec:termination}
\index{termination}
The property of termination concerns both loops and recursive function
calls.
% For that purpose, loops can be annotated with a \texttt{loop
%  variant}\index{loop variant} clause, and functions can be annotated
%with a \decreases{} clause.
Termination is guaranteed by attaching a measure function to each loop
(an aspect already addressed in Section~\ref{sec:loop-variant}) 
and each recursive function.
By default, a measure is an
integer expression, and measures are compared using the usual ordering
over integers (Section~\ref{sec:integermeasures}). It is also possible
to define
measures using other domains and/or using a different ordering relation
(Section~\ref{sec:generalmeasures}).

\subsection{Integer measures}
\label{sec:integermeasures}
\indextt{decreases}\indextt{variant}
Functions are annotated with integer measures with the syntax
\begin{listing-nonumber}
//@ decreases e;
\end{listing-nonumber}
and loops are annotated similarly with the syntax
\begin{listing-nonumber}
//@ loop variant e;
\end{listing-nonumber}
where the logic expression \lstinline|e| has type
\lstinline|integer|.
For recursive calls, or for loops, this expression must decrease for
the
relation \lstinline|R| defined by
\begin{listing-nonumber}
R(x,y) <==> x > y && x >= 0.
\end{listing-nonumber}
In other words, the measure must be a decreasing sequence of integers
which remain nonnegative, except possibly for the last value of the
sequence (See example~\ref{ex:loopvariant}).

\begin{example}
  The clause \lstinline|loop variant u-l;| can be added to the loop 
  annotations of the example~\ref{ex:bsearch2}.
  The measure \lstinline|u-l| decreases
  at each iteration, and remains nonnegative, except at the last
  iteration where it may become negative.
\begin{listing}{16}
  @ ...
  @ loop variant u-l; */
while ...
\end{listing}
\end{example}

\subsection{General measures}
\label{sec:generalmeasures}

More general measures on other types can be provided, using the
keyword \lstinline|for|. For functions it becomes
\begin{listing-nonumber}
//@ decreases e for R;
\end{listing-nonumber}
and for loops
\begin{listing-nonumber}
//@ loop variant e for R;
\end{listing-nonumber}
In those cases, the logic expression \lstinline|e| has some type
$\tau$ and \lstinline|R|
must be a relation on $\tau$, that is a binary predicate declared 
(see Section~\ref{sec:logicspec} for details) as
\begin{listing-nonumber}
//@ predicate R($\tau$ x, $\tau$ y) $\cdots$
\end{listing-nonumber}
Of course, to guarantee
termination, it must be proved that \lstinline|R| is a well-founded relation.

\begin{example}
  The following example illustrates a variant annotation
  using a pair of integers, ordered lexicographically.
  \listinginput{1}{lexico.c}
\end{example}

\subsection{Recursive function calls}

The precise semantics of measures on recursive calls, especially in
the general case of mutually recursive functions, is given as follows.
We call a set of mutually recursive functions that
is a strongly connected component of the call graph
a \emph{cluster}.
Within each cluster, each function must be annotated with a \decreases\
clause with the same relation \lstinline|R| (syntactically). Then, in the body
of any function \lstinline|f| of that cluster, any recursive call to a function
\lstinline|g| must occur in a state where the measure attached to
\lstinline|g| is smaller
(w.r.t \lstinline|R|) than the measure of \lstinline|f| in the pre-state of \lstinline|f|. This also
applies when \lstinline|g| is \lstinline|f| itself.

\begin{example}
  Here are the classical factorial and Fibonacci functions:
  \listinginput{1}{fact.c}
\end{example}

\begin{example}
  This example illustrates mutual recursion:
  \listinginput{1}{mutualrec.c}
\end{example}

% \subsection{Function termination}

%% TODO: a mettre plutot dans les contrats
%% clause 'terminates P' specifie que si P est vrai dans le pre-state,
%% alors la fonction ou le statement objet du contrat se termine en temps
%% fini.
%%
%% pas de valeur par defaut
%%
%% Patrick propose plutot la negation: 'diverges P' car ce que l'on veut
%% specifier c'est que la fonction ne boucle indefiniment.
%%
%% en faveur de prendre 'diverges' : c'est comme ca en JML.


\subsection{Non-terminating functions}
\label{sec:non-term-funct}
\indextt{terminates}
\experimental

There are cases where a function is not supposed to terminate. For
instance, the \lstinline|main| function of a reactive program might be a
\lstinline|while(1)| that indefinitely waits for an event to process. More
generally, a function can be expected to terminate only if some
preconditions are met. In those cases, a \lstinline|terminates| clause can
be added to the contract of the function, using the following form:

\begin{listing-nonumber}
//@ terminates p;
\end{listing-nonumber}

The semantics of such a clause is as follows: if \lstinline|p| holds, then the
function is guaranteed to terminate (more precisely, its
termination must be proved). If such a clause is not present (and in
particular if there is no function contract at all), it
defaults to \lstinline|terminates \true;| that is, the function is supposed
to always terminate, which is the expected behavior of most
functions.

Note that nothing is specified for the case where \lstinline|p| does not hold:
the function may terminate or not. In particular,
\lstinline|terminates \false;| does not imply that the function loops
forever. A possible specification for a function that never terminates
is the following:\ifCPP{\footnote{in \lang, this specification would also include \lstinline|throws \\false;|}}
\begin{listing}{1}
/*@ ensures \false;
    terminates \false;
*/
void f() { while(1); }
\end{listing}

\begin{example}
  A concrete example of a function that may not always terminate is
  the \lstinline|incr_list| function of example \ref{ex:locations-list}. In
  fact, the following contract is also acceptable for this function:
\listinginput{1}{terminates_list.c}
\end{example}

\section{Logic specifications}
\label{sec:logicspec}
\index{logic specification}\index{specification}
\begin{figure}[t]
  \begin{cadre}
%%  \vfill \input{logic.bnf}
    \vfill\end{cadre}
  \caption{Grammar for global logic definitions}
\label{fig:gram:logic}
\end{figure}
The language of logic expressions used in annotations can be extended
by declarations of new logic types, and new constants, logic functions
and predicates. These declarations follow the classical setting of
\emph{algebraic specifications}.
The grammar for these declarations is given in Figure~\ref{fig:gram:logic}.

\subsection{Predicate and function definitions}
New functions and predicates can be \emph{defined} by explicit
expressions, given after an equal sign.
\begin{example}
  The following code \listinginput{1}{signdef.c} illustrates the
  definition of a new predicate \lstinline{is_positive} with an integer
  parameter and a new logic function \lstinline{sign} with a real
  parameter returning an integer.
\end{example}

\ifCPP{Logic functions and predicates that appear within \lang
aggregate declarations may be declared \lstinline|static|, meaning that 
they do not have an implicit \lstinline|this| receiver.}

\ifCPP{\NAME expressions may include applications of predicates and logic functions.
They may not include applications of \lang functions. This includes applications of
overloaded operators. For example, the \lstinline|==| operation applied to two class objects
is applying the built-in \NAME operation of equality between two structures, 
not a user-defined \lang equality operation on that class.}

\subsection{Lemmas}
Lemmas are user-given propositions, a facility that might help theorem
provers establish validity of ACSL specifications.

\begin{example}
  The following lemma
  \listinginput{1}{mean.c}
  is a useful hint for a program like binary search.
\end{example}

Of course, a complete verification of an ACSL specification has to
provide a proof for each lemma.

\subsection{Inductive predicates}
\label{sec:inductivepredicates}
\index{inductive predicates}

A predicate may also be defined by an inductive definition. The
grammar for this style of definition is given in
Figure~\ref{fig:gram:inductive}.
\index{inductive definitions}
\begin{figure}[t]
  \begin{cadre}
      \input{inductive.bnf}
    \end{cadre}
  \caption{Grammar for inductive definitions}
\label{fig:gram:inductive}
\end{figure}

In general, an inductive definition of a predicate \lstinline|P| has the form
\begin{listing}{1}
/*@ inductive P(x$_1$,$\ldots$,x$_n$) {
  @   case c$_1$ : p$_1$;
...
  @   case c$_k$ : p$_k$;
  @ }
  @*/
\end{listing}
where each \lstinline|c$_i$| is an identifier and each \lstinline|p$_i$| 
is a proposition.

The semantics of such a definition is that \lstinline|P| is the least fixpoint
of the cases, i.e. is the smallest predicate (in the sense that it is
false the most often) satisfying the propositions \lstinline|p$_1,\ldots,$p$_k$|.
With this general form, the existence of a least fixpoint is not
guaranteed, so tools might enforce syntactic conditions on the form of
inductive definitions. A standard syntactic restriction could be to
allow only propositions \lstinline|p$_i$| of the form
\begin{listing-nonumber}
\forall y$_1$,`\dots`,y$_m$, h$_1$ ==> $\cdots$ ==> h$_l$ ==> P(t$_1$,`\dots`,t$_n$)
\end{listing-nonumber}
where \lstinline|P| occurs only positively in hypotheses \lstinline|h$_1,\ldots,$h$_l$|
(definite Horn clauses,
\url{http://en.wikipedia.org/wiki/Horn_clause}).

\begin{example}
  The following introduces a predicate \lstinline|isgcd(x,y,d)|, which means
  that \lstinline|d| is the greatest common divisor of \lstinline|x|
  and \lstinline|y|.
  \listinginput{1}{isgcd.c}
  This definition uses definite Horn clauses, hence is consistent.
\end{example}

Example~\ref{ex:locations-list} already introduced an inductive definition of
reachability in linked-lists, and was also based on definite Horn
clauses, and is thus consistent.

\subsection{Axiomatic definitions}

Instead of an explicit definition, one may introduce an
\emph{axiomatic} definition for a set of types, predicates and logic
functions, which amounts to declaring the expected profiles and a set of
axioms. The grammar for those constructions is given in
Figure~\ref{fig:gram:logicdecl}.

\indextt{axiomatic}
\begin{figure}[t]
  \begin{cadre} 
    \input{logicdecl.bnf}
    \end{cadre}
  \caption{Grammar for axiomatic declarations}
\label{fig:gram:logicdecl}
\end{figure}

\begin{example}
  The following axiomatization introduces a theory of finite lists of
  integers a la LISP.
  \listinginput{1}{intlists.c}
\end{example}

Unlike inductive definitions, there is no syntactic condition that
 guarantees that axiomatic definitions are consistent. It is usually
up to the user to ensure that the introduction of axioms does not lead
to a logical inconsistency.

\begin{example}
  The following axiomatization
  \listinginput{1}{sign.c}
  is inconsistent since
  it implies \lstinline|sign(0.0) == 1| and \lstinline|sign(0.0) == -1|,
  hence \lstinline|-1 == 1|
\end{example}

The axiomatic construct is solely a grouping construct, meant to organize declarations that together define the behavior of a collection of types, predicates and logic functions. Currently the grammar 
requires logic function and predicate declarations and axioms to be written inside an axiomatic; only full definitions may be written outside an axiomatic.

\ifCPP{An axiomatic construct does not introduce a \lang nested scope, as do namespaces and classes.\footnote{This point is under discussion. It would be more convenient and consistent to have axiomatics be a nested scope, but this would not be backward compatible.}}

\subsection{Polymorphic logic types}\label{sec:polym-logic-types}
\index{type!polymorphic}
\index{polymorphism}

We consider here an algebraic specification setting based on
multi-sorted logic, where types can be \emph{polymorphic} (that is, 
parametrized by other types). For example, one may declare the type of
polymorphic lists as
\listinginput{1}{listdecl.c}
One can then consider for
instance list of integers (\lstinline|list <integer>|), list of pointers
(e.g. \lstinline|list <char*>|), list of list of reals
(\lstinline|list<list <real> >|\footnote{In this latter case, note that the two
  '\texttt{>}' must be separated by a space, to avoid confusion with
  the shift operator.}), etc.

The grammar of Figure~\ref{fig:gram:logic} contains rules for
declaring polymorphic types and using polymorphic type
expressions.
%Notice that type variables are identifiers preceded by
%the quote character.


\subsection{Recursive logic definitions}
\index{recursion}
Explicit definitions of logic functions and predicates can be
recursive. Declarations in the same bunch of logic declarations are
implicitly mutually recursive, so that mutually recursive functions are
possible too.

\begin{example}
  The following logic declaration
  \listinginput{1}{max_index.c}
  defines a logic function that returns the maximal index \lstinline|i| between
  \lstinline|0| and \lstinline|n-1| such that \lstinline|t[i]=0|.
\end{example}

%\begin{example} The following introduce $n$-ary trees using list of children.
%  \input{mutualrec.pp}
%\end{example}

There is no syntactic condition on such recursive
definitions, such as limitation to primitive recursion. In essence, a
recursive definition of the form \lstinline+f(args) = e;+ where
\lstinline+f+ occurs in expression \lstinline+e+ is just a shortcut
for an axiomatic declaration of \lstinline+f+ with an 
axiom~\lstinline+\forall args; f(args) = e+.  In other words, recursive
definitions are not guaranteed to be consistent, in the same way that
axiomatics may introduce inconsistency. Of course, tools might provide
a way to check consistency.

\subsection{Higher-order logic constructions}
\label{sec:higherorder}

\experimental

\begin{figure}[t]
  \begin{cadre}
      \input{higherorder.bnf}
    \end{cadre}
  \caption{Grammar for higher-order constructs}
\label{fig:gram:higherorder}
\end{figure}

Figure~\ref{fig:gram:higherorder} introduces new term constructs for
higher-order logic.
\begin{description}
\item[Abstraction]\indexttbs{lambda}
  The term \lstinline|\lambda $\tau_1$ x$_1$,$\ldots$,$\tau_n$ x$_n$; t|
  denotes the $n$-ary logic function that maps \lstinline|x$_1,\ldots,$x$_n$| to
  \lstinline|t|. It has the same precedence as \Forall and \Exists
\item[Extended quantifiers]
  Terms
 \lstinline|$\backslash quant$(t$_1$,t$_2$,t$_3$)|
  where $quant$ is \lstinline|max|\indexttbs{max},
  \lstinline|min|\indexttbs{min},
  \lstinline|sum|\indexttbs{sum},
  \lstinline|product|\indexttbs{product}
  or \lstinline|numof|\indexttbs{numof}
  are extended quantifications. \lstinline|t$_1$| and \lstinline|t$_2$| must have type
  \lstinline|integer|, and \lstinline|t$_3$| must be a unary function with an integer
  argument, and a numeric value (integer or real) except for
  \lstinline|\numof| for which it should have a boolean value. Their
  meanings are given as follows:
  \begin{tabular}{rcl}
    \lstinline|\max(i,j,f)| &=&
    $\max \{ \lstinline|f(i)|,\lstinline|f(i+1)|, \ldots, \lstinline|f(j)| \}$\\
    \lstinline|\min(i,j,f)| &=&
    $\min \{ \lstinline|f(i)|,\lstinline|f(i+1)|, \ldots, \lstinline|f(j)| \}$\\
    \lstinline|\sum(i,j,f)| &=&
    $\lstinline|f(i)|+\lstinline|f(i+1)|+\cdots+\lstinline|f(j)|$ \\
    \lstinline|\product(i,j,f)| &=&
    $\lstinline|f(i)|\times\lstinline|f(i+1)|\times\cdots\times\lstinline|f(j)|$
    \\
    \lstinline|\numof(i,j,f)| &=&
    $\#\{ \lstinline|k| \mid \lstinline|i| \leq \lstinline|k| \leq
          \lstinline|j| \land \lstinline|f(k)| \}$ \\
&=& \lstinline|\sum(i,j,\lambda integer k ; f(k) ? 1 : 0)|
  \end{tabular}

  If \lstinline|i>j| then \lstinline|\sum| and \lstinline|\numof| above are 0,
  \lstinline|\product| is 1, and \lstinline|\max| and \lstinline|\min| are
  unspecified (see Section~\ref{sec:twovaluedlogic}).
\item[Array slice update]
  A term of the form
  \lstinline|{ $a$ \with [ $low$ .. $up$ ] = $f$}| allows updating a slice of
  an array. $a$ must be an array of $\tau$ and $f$
  a unary function taking as argument
  an \lstinline|integer| and returning a value of type $\tau$. Such a term
  denotes an array $a'$ such that:
  \[
    a'[i] = \left\{\begin{array}{lr}
                    a[i] & \mathrm{if~} i < low \\
                    f(i) & \mathrm{if~} low \leq i \leq up \\
                    a[i] & \mathrm{if~} i > up
                    \end{array}\right.
  \]
If $low$ (resp. $up$) is missing, then all the lower (resp. upper) part of
the array gets modified in $a'$. If both bounds are omitted, all elements of
$a'$ are computed using $f$.

As a special case, a term of the form
\lstinline|{ $a$ \with [ $low$ .. $up$ ] = $v$}| where $v$ is a term of type
$\tau$ is equivalent to
\lstinline|{ $a$ \with [ $low$ .. $up$ ] = \lambda $\mathbb{Z}$. $v$ }|, i.e.
it evaluates to an array where the relevant cells all contain the same
value $v$.

Finally, ranges can also be used in designated initializers
(see section \ref{sec:aggregate}), with the same semantics as above.
\end{description}


\begin{example}
  \label{ex:higherorder}
  Function that sums the elements of an array of doubles.
  \listinginput{1}{sum.c}
\end{example}

\begin{example}
  \label{ex:arraysliceupdate}
  Properties of arrays initialized as a whole slice
  \listinginput{1}{arrayslice.c}
\end{example}

\subsection{Concrete logic types}\label{sec:concrete-logic-types}
\index{type!concrete}
\label{sec:concretetypes}
\experimental

\begin{figure}[t]
  \begin{cadre}
      \index{type!record}\index{type!sum}
      \input{logictypedecl.bnf}
    \end{cadre}
  \caption{Grammar for concrete logic types and pattern-matching}
\label{fig:gram:logictype}
\end{figure}

Logic types may not only be declared but also be given a
definition. Defined logic types can be either record
types\index{type!record}, sum
types\index{type!sum}, product (tuple) types, or function types. These definitions may be recursive.
For record types, the field access notation $t.id$ can be used;
for sum types, a pattern-matching construction is available.
Grammar rules for these additional constructions are given in
Figure~\ref{fig:gram:logictype}

\begin{example}
  The declaration
  \listinginput{1}{listdef.c}
  introduces a concrete definition of finite lists. The logic definition
  \listinginput{1}{listlengthdef.c}
  defines the length of a list by recursion and pattern-matching.
\end{example}


\subsection{Hybrid functions and predicates}
\label{sec:logicalstates}
\index{hybrid!function}
\index{hybrid!predicate}

Logic functions and predicates may take arguments with
either (pure) C type or logic
type. Such a predicate (or function)
can either be defined with the same syntax as before (or axiomatized).
However, such definitions usually depend on one or
more program points, because it depends upon memory states, \emph{via}
expressions such as:
\begin{itemize}
\item pointer dereferencing: \lstinline|*p|, \lstinline|p->f|;
\item array access: \lstinline|t[i]|;
\item address-of operator: \lstinline|&x|;
\item built-in predicate depending on memory: \valid
% \item others ?
\end{itemize}
To make such a definition safe, it is mandatory to add after the
declared identifier a set of labels, between curly braces. We then speak
of a \textit{hybrid} predicate (or function).
The grammar for \textit{ident} is extended as shown on
Figure~\ref{fig:gram:logiclabels}. Expressions
as above must then be enclosed in an \at{} construct to refer to a
given label. However, to ease reading of such logic expressions, it
is allowed to omit a label whenever there is only one label in the
context.

\begin{figure}[t]
  \begin{cadre}
      \input{logiclabels.bnf}
    \end{cadre}
  \caption{Grammar for logic declarations with labels}
\label{fig:gram:logiclabels}
\end{figure}

\begin{example}\label{ex:nb_occ}
  The following annotations declare a function that returns the
  number of occurrences of a given double in a memory block storing doubles
  between the given indexes, together with the related axioms.  It
  should be noted that without labels, this axiomatization would be
  inconsistent, since the function would not depend on the values
  stored in t, hence the two last axioms would say both that \lstinline|a==b+1|
  and \lstinline|a==b| for some \lstinline|a| and \lstinline|b|.
  \listinginput{1}{nb_occ.c}
\end{example}

\begin{example}
  This second example defines a predicate that indicates whether two
  memory blocks of the same size are a permutation of each other. It
  illustrates the use of more than a single label. Thus, the \lstinline|\at|
  operator is mandatory here. Indeed the two blocks
  may come from two distinct memory states. Typically, one of the post
  conditions of a sorting function would be \lstinline|permut{Pre,Post}(t,t)|.
  \listinginput{1}{permut.c}
\end{example}

% resurected reads clause

\subsection{Memory footprint specification: \texorpdfstring{\lstinline|reads|}{reads} clause}

\begin{figure}[t]
  \begin{cadre}
      \input{logicreads.bnf}
    \end{cadre}
  \caption{Grammar for logic declarations with \lstinline|reads| clauses}
\label{fig:gram:logicreads}
\end{figure}


\experimental

Logic declarations may be augmented with a \reads{} clause, with the
syntax given in Figure~\ref{fig:gram:logicreads}, which extends the
syntax in Figure~\ref{fig:gram:logic}. This feature allows specifying the
\emph{footprint} of a hybrid predicate or function, that is, the set of
memory locations that it depends on. From such information, one
might deduce properties of the form $f\{L_1\}(args) = f\{L_2\}(args)$
if it is known that between states $L_1$ and $L_2$, the memory changes are
disjoint from the declared footprint.
Only mutable locations need be listed in a \lstinline|reads| footprint: 
locations that hold constants that do not change in the course of a program may be omitted.

\begin{example}
  The following is the same as example~\ref{ex:nb_occ} augmented with
  a \lstinline|reads| clause.
  \listinginput{1}{nb_occ_reads.c}
  If for example a
  piece of code between labels \lstinline|L_1| and \lstinline|L_2|
  only modifies \lstinline|t[k]| for
  some index \lstinline|k| outside \lstinline|i..j|, then one can deduce that
  \lstinline|nb_occ{L_1}(t,i,j,e)==nb_occ{L_2}(t,i,j,e)|.
\end{example}

\subsection{Specification Modules}
\label{sec:specmodules}
\index{module}

\experimental

\ifCPP{\review{Namespaces provide this capability. Do we need modules as well?}}

\notimplemented{Specification modules can be provided} to encapsulate
several logic definitions, for example
\listinginput{1}{listmodule.c}
Module components are then accessible using a qualified notation like
\begin{notimplementedenv}\lstinline|List::length|\end{notimplementedenv}.

\ifCPP{In \NAME, \lang namespaces can be used for this purpose.}

Predefined algebraic specifications can be provided as
libraries\index{library} (see
section~\ref{chap:lib}), and imported using a construct like
\begin{notimplementedenv}
\listinginput{1}{import.c}
\end{notimplementedenv}
where the file \lstinline|List.acsl| contains logic
definitions, like the \lstinline|List| module above.

\ifCPPinput{cpp-class-contracts}
\ifCPPinput{cpp-enum}
\ifCPPinput{cpp-templates}
\ifCPPinput{cpp-types}
\ifCPPinput{cpp-visibility}
\ifCPPinput{cpp-auto}
\ifCPPinput{cpp-namespaces}



\section{Pointers and physical addressing}
\label{sec:pointers} 
% [Patrick B.] START proposition:
The grammar for terms and predicates is
extended with new constructs given in Figure~\ref{fig:gram:memory}. 
The arguments of these built-in predicates are \textsl{terms} or \textsl{location-lists} designating sets of locations.
Each argument is a set of values of some common pointer type as defined in Section~\ref{sec:locations}. As indicated below where necessary,
many built-in functions and predicates dealing with
pointers depend on the size of the referenced type. Thus, they cannot be given
a pointer to \lstinline|void| as an argument. On the
other hand, a pointer referencing an incomplete type (hence having an
abstract size) is possible.

\begin{figure}[t]
  \begin{cadre}
      \input{memory.bnf}
    \end{cadre}
  \caption{Grammar extension of terms and predicates about memory}
\label{fig:gram:memory}
\end{figure}
% END proposition:



\subsection{Memory blocks and pointer dereferencing}
\label{subsec:memory}
C memory is structured into allocated blocks that can come either from a 
declarator or a call to one of the \lstinline|calloc|, \lstinline|malloc| or
\lstinline|realloc| functions. A block is characterized by its base address, 
which is the address of the declared object (the first declared object 
in case of an array declarator) or the pointer returned by the allocating 
function (when the allocation succeeds), and its length.

ACSL provides the following built-in functions to deal with allocated blocks.
Each of them takes an optional label identifier as argument.
The default value of that label is defined in Section~\ref{sec:default-logic-labels}.
\begin{itemize}
\item \lstinline|\base_addr{L}(p)|\indexttbs{base\_addr}
returns the base address of the allocated block
containing, at the label \lstinline|L|, the pointer \lstinline|p|
\\ \makebox[5mm]{} \lstinline|\base_addr{id} : void* $\ra$ char*|

\item \lstinline|\block_length{L}(p)|\indexttbs{block\_length}
  returns the length (in bytes) of the allocated block containing, 
  at the label \lstinline|L|, its argument pointer.
\\ \makebox[5mm]{} \lstinline|\block_length{id} : void* $\ra$ size_t|

\end{itemize}


In addition, dereferencing a pointer may lead to run-time errors. A pointer
\lstinline|p| is said to be \emph{valid} if \lstinline|*p| is guaranteed to
produce a definite value according to the C standard~\cite{standardc99}. The
following built-in predicates deal with this notion:
\begin{itemize}
\item \valid\indexttbs{valid} applies to a tset  
(see Section~\ref{sec:locations}) each of whose elements has some common pointer type (other than \lstinline|void*|). 
\lstinline|\valid{L}(s)| holds if and only if
 dereferencing any $p\in \lstinline|s|$ is safe  at label \lstinline|L|, both for reading from 
\lstinline|*p| and writing to it. In particular,
\lstinline|\valid{L}(\empty)| holds for any label \lstinline|L|. 
\\ \makebox[5mm]{} \lstinline|\valid{id} : set<$\alpha$ *> $\ra$ boolean|
\item 
\lstinline|\valid_read|\indexttbs{valid\_read}
applies to a tset of some pointer type (other than \lstinline|void*|)
and holds if and only if it is safe to read from all the pointers in the set
\\ \makebox[5mm]{} \lstinline|\valid_read{id} : set<$\alpha$ *> $\ra$ boolean|
\end{itemize}

\lstinline|\valid{L}(s)| implies \lstinline|\valid_read{L}(s)| but the reverse is 
not true. In particular, it is allowed to read from a string literal, but not 
to write in it (see \cite{standardc99}, 6.4.5\S6).

The status of \valid and \lstinline|\valid_read| constructs depends on the
type of their argument. Namely, \lstinline|\valid{L}((int *) p)| and 
\lstinline|\valid{L}((char *)p)| are not equivalent. On the other hand, if we 
ignore potential alignment constraints, the following equivalence is true for any pointer \lstinline|p|:
\begin{listing-nonumber}
\valid{L}(p) <==> \valid{L}(((char *)p)+(0 .. sizeof(*p)-1))
\end{listing-nonumber}
and similarly for \lstinline|\valid_read|
\begin{listing-nonumber}
\valid_read{L}(p) <==> \valid_read{L}(((char *)p)+(0 .. sizeof(*p)-1))
\end{listing-nonumber}

Some shortcuts are provided:
\begin{itemize}
\item \lstinline|\null|\indexttbs{null} is an
  extra notation for the
  null pointer (\emph{i.e.} a shortcut for \lstinline|(void*)0|)\ifCPP{ and, in \lang, for \lstinline|nullptr|}. 
  As in C itself (see \cite{standardc99}, 6.3.2.3\S3),
  the constant \lstinline|0| can have any pointer type. Note that 
  \lstinline|\valid{L}((char*)\null)| and \lstinline|\valid_read{L}((char*)\null)|
  are always false, for any
  logic label \lstinline|L|.
% \footnote{or to \texttt{NULL}, if
%    annotations are pre-processed are the appropriate inclusion of
%    \texttt{stddef.h} is added}
\item \lstinline|\offset{L}(p)|%
  \indexttbs{offset}
  returns the offset in bytes between \lstinline|p| and its base address
\\ \makebox[5mm]{} \begin{tabular}{lll}
    \lstinline|\offset{id}| &:& \lstinline|void* $\ra$ size_t| \\
    \lstinline|\offset{L}(p)| &=& \lstinline|(char*)p - \base_addr{L}(p)| \\
  \end{tabular} \\
Again, if there are no alignment constraints,
  the following property holds: for any set of pointers
\lstinline|s| and label \lstinline|L|, \lstinline|\valid_read{L}(s)| if and only if for all \lstinline|p$\in$s|:
  \begin{listing-nonumber}
    \offset{L}(p) >= 0 && \offset{L}(p) + sizeof(*p) <= \block_length{L}(p)
  \end{listing-nonumber}

\end{itemize}

\subsection{Separation}\label{sec:separated} 

ACSL provides a built-in function to deal with separation of locations:

\begin{itemize}
% [Patrick B.] START proposition:
\item \lstinline|\separated|\indexttbs{separated}
applies to tsets (see Section~\ref{sec:locations}) of some common pointer type
other than \lstinline|void*|. 
\lstinline|\separated(s$_1$,s$_2$)|
holds for any set of pointers \lstinline|s$_1$| and \lstinline|s$_2$| 
if and only if for all \lstinline|p$\in$s$_1$| and \lstinline|q$\in$s$_2$|:
\begin{listing-nonumber}
  forall integer i,j; 0 <= i < sizeof(*p), 0 <= j < sizeof(*q)
     ==>  (char*)p + i != (char*)q + j 
\end{listing-nonumber}

In fact, \lstinline|\separated| is an $n$-ary predicate.\\
\lstinline|\separated(s$_1$,..,s$_n$)|\indexttbs{separated} means
that for each
$i\neq j$, \lstinline|\separated(s$_i$,s$_j$)|.
% END proposition:
\end{itemize}

Note that \lstinline|\separated| does not have a label argument. The separation of sets of locations
ca be determined without reference to the content of the heap, so no reference to a heap state is needed.
However the evaluation of each argument may depend on a heap state, so \lstinline|\at| expressions are often needed.


\subsection{Dynamic allocation and deallocation}
\label{sec:allocation-clause}
\indextt{allocates}\indextt{frees}
\index{allocation}\index{deallocation}\index{dynamic allocation}

\experimental

\textsl{Allocation-clauses} allow specifying which memory locations 
are dynamically allocated or deallocated.
The grammar for those constructions is given in Figure~\ref{fig:gram:allocation}.

\lstinline|allocates \nothing| and \lstinline|frees \nothing| are respectively 
equivalent to \lstinline|allocates \empty| and \lstinline|frees \empty|; 
it is left for convenience like for \assigns clauses.

\begin{figure}[t]
  \begin{cadre}
      \input{allocation.bnf}
    \end{cadre}
  \caption{Grammar for dynamic allocations and deallocations}
\label{fig:gram:allocation}
\end{figure}

\subsubsection{Allocation clauses for function and statement contracts}
\label{subsec:allocation-contract}

Clauses \allocates and \frees are tied together. The simple contract  
\begin{listing-nonumber}
/*@ frees P$_1$,P$_2$,`\dots`;
  @ allocates Q$_1$,Q$_2$,`\dots`;
  @*/
\end{listing-nonumber}
means that any memory address that does not belong to the union of the sets \lstinline|P$_i$| and \lstinline|Q$_j$| of
some common pointer type other than \lstinline|void*|
has the same {\sl allocation status} 
(see below) in the post-state as in the pre-state. The only difference
between \lstinline|allocates| and \lstinline|frees| is that sets 
\lstinline|P$_i$| are evaluated 
in the pre-state, and sets \lstinline|Q$_i$| are evaluated in the post-state.

The built-in type \indextt{allocation\_status}\lstinline|allocation_status|
can take the following values:
\indexttbs{static}\indexttbs{register}\indexttbs{automatic}\indexttbs{dynamic}
\indexttbs{unallocated}
\begin{notimplementedenv}
\begin{listing-nonumber}
/*@
type allocation_status = 
    \static | \register | \automatic | \dynamic | \unallocated;
*/
\end{listing-nonumber}
\end{notimplementedenv}

Built-in function
\begin{notimplementedenv}\lstinline|\allocation{L}(p)|\end{notimplementedenv}%
\indexttbs{allocation}
returns the allocation status of the block containing, at the label 
\lstinline|L|, the pointer \lstinline|p| 
\\ \makebox[5mm]{} \lstinline|\allocation{id} : void* $\ra$ allocation_status|

This function is such that for any pointer \lstinline|p| and label \lstinline|L|
\begin{listing-nonumber}
\allocation{L}(p) == \allocation{L}(\base_addr(p))
\end{listing-nonumber}
and
\begin{listing-nonumber}
\allocation{L}(p)==\unallocated ==> !\valid_read{L}((char*)p)
\end{listing-nonumber}

\allocates \lstinline|Q$_1$,$\ldots$,Q$_n$| is equivalent to the postcondition
\begin{listing-nonumber}
\forall char* p; 
\separated(\union(Q$_1$,$\ldots$,Q$_n$),p)==>
     (\base_addr{Here}(p)==\base_addr{Pre}(p)
      && \block_length{Here}(p)==\block_length{Pre}(p)
      && \valid{Here}(p)<==>\valid{Pre}(p)
      && \valid_read{Here}(p)<==>\valid_read{Pre}(p)
      && \allocation{Here}(p)==\allocation{Pre}(p))
\end{listing-nonumber}

In fact, just as the \assigns clause does not specify precisely which memory locations are
modified (just which are permitted to be modified),
the \textsl{allocation-clauses} do not specify which memory locations 
are dynamically allocated or deallocated (just those that might be allocated or deallocated).
Pre-conditions and post-conditions should be added to complete the specifications
about allocations and deallocations.
The following shortcuts can be used for that:

\begin{itemize}
\item \lstinline|\allocable{L}(p)|\indexttbs{allocable}
holds if and only if
the pointer \lstinline|p| refers, at the label \lstinline|L|, 
to the base address of 
an unallocated memory block.
\\ \makebox[5mm]{} \lstinline|\allocable{id} : void* $\ra$ boolean|
\\
For any pointer \lstinline|p| and label \lstinline|L|
\begin{listing-nonumber}
\allocable{L}(p) <==> (\allocation{L}(p)==\unallocated
                         && (void*)p==(void*)\base_addr{L}(p))
\end{listing-nonumber}
  
\item \lstinline|\freeable{L}(p)|\indexttbs{freeable}
holds if and only if
the pointer \lstinline|p| refers, at the label \lstinline|L|, 
to the base address of an allocated memory block 
that can be safely released using the C function \lstinline|free|.
Note that \lstinline|\freeable(\null)| does not hold, despite \lstinline|NULL|
being a valid argument to the C function \lstinline|free|.
%Note: free() is described in 7.20.3.2 of the ISO/IEC 9899/1999 (C99) standard
\\ \makebox[5mm]{} \lstinline|\freeable{id} : void* $\ra$ boolean|
\\
For any pointer \lstinline|p| and label \lstinline|L|
\begin{listing-nonumber}
\freeable{L}(p) <==> (\allocation{L}(p)==\dynamic
                        && (void*)p==(void*)\base_addr{L}(p))
\end{listing-nonumber}
  
\item \lstinline|\fresh{L$_0$,L$_1$}(p,n)|
\indexttbs{fresh}
  indicates that \lstinline|p| refers to the base address of an allocated memory block at label 
  \lstinline|L$_1$|, 
  but that it is not the case at label \lstinline|L$_0$|. 
  The predicate ensures also that, at label \lstinline|L$_1$|, the length
  (in bytes) of the block allocated dynamically equals  \lstinline|n|.
\\ \makebox[5mm]{} \lstinline|\fresh{id,id} : void*, integer $\ra$ boolean|
\\
For any pointer \lstinline|p| and labels \lstinline|L$_0$| and \lstinline|L$_1$|
\begin{listing-nonumber}
\fresh{L$_0$,L$_1$}(p,n) <==> (\allocable{L$_0$}(p) && \freeable{L$_1$}(p) && 
                         \block_length{L$_1$}(p)==n &&
                         \valid{L$_1$}((char*)p+(0 .. (n-1)))
\end{listing-nonumber}
\end{itemize}

\begin{example}
  \lstinline|malloc| and \lstinline|free| functions can be specified as follows.
  \listinginput{1}{malloc_free_fn.c}
  Default labels for constructs dedicated to memory are 
  such that the logic label \lstinline|Here| can be omitted.
\end{example}

When a behavior contains only one of the two allocation clauses,
the given clause specifies the whole set of memory addresses to consider.
This means that the set value for the other clause of that behavior defaults to \nothing.
Now, when neither of the two allocation clauses is given, the meaning is different
for anonymous behaviors and named behaviors:
\begin{itemize}
\item a named behavior without allocation clauses does not specify anything about
      allocations and deallocations. 
      The allocated and deallocated memory blocks are in fact specified by the 
      anonymous behavior of the contract.
      There is no condition to verify for these named behaviors about allocations 
      and deallocations;
\item for an anonymous behavior, the absence of allocation clauses means that there is no newly 
      allocated nor deallocated memory block. 
      That is equivalent to stating \allocates \nothing; (which is equivalent to  \allocates \nothing; \frees \nothing;).
\end{itemize}
These rules are such that contracts without any allocation clause
should be considered 
as having only one \lstinline|allocates \nothing;| 
leading to a condition to verify for 
each anonymous behavior.

\begin{example}
  More precise specifications can be given using named behaviors under the 
  assumption of \assumes clauses.
  \listinginput{1}{malloc-free2-fn.c}
  The behaviors named \lstinline|allocation| and
  \lstinline|deallocation| do not 
  need an allocation clause.
  For example, the allocation constraint of the \lstinline|allocation| behavior 
  is given by the clause \allocates \result of the anonymous behavior of the  
  \lstinline|malloc| function contract. 
  To set a stronger constraint into the behavior named \lstinline|no_allocation|,
  the clause \allocates \nothing should be given.
\end{example}

\subsubsection{Allocation clauses for loop annotations}
\index{loop!allocation}\index{loop!deallocation}

Loop annotations may contain similar clauses allowing one to specify which 
memory locations 
are dynamically allocated or deallocated by a loop.
The grammar for those constructions is given in
 Figure~\ref{fig:gram:allocation}.

The clauses \Loop \allocates and \Loop \frees are tied together.
The simple loop annotation
\begin{listing-nonumber}
/*@ loop frees P$_1$,P$_2$,`\dots`;
  @ loop allocates Q$_1$,Q$_2$,`\dots`; */
\end{listing-nonumber}
means that any memory address that does not belong to the union of sets of 
terms
\lstinline|P$_i$| and  \lstinline|Q$_i$|
has the same allocation status in the current state as 
before entering the loop. 
The only difference between these two clauses is that sets 
\lstinline|P$_i$| are evaluated in the state before entering the loop
(label \lstinline|LoopEntry|), 
and \lstinline|Q$_i$| are evaluated in the current loop state 
(label \lstinline|LoopCurrent|).

Just as for \lstinline|loop assigns|, the loop annotations
\lstinline|loop frees| and \lstinline|loop allocates| define a loop invariant.

More precisely, this loop annotation
\begin{listing-nonumber}
//@ loop allocates Q$_1$,`\dots`,Q$_n$; */
\end{listing-nonumber}
is equivalent to the loop invariant
\begin{listing-nonumber}
\forall char* p; 
\separated(\union(Q$_1$,$\ldots$,Q$_n$),p) ==>
   (\base_addr{Here}(p)==\base_addr{LoopEntry}(p)
    && \block_length{Here}(p)==\block_length{LoopEntry}(p)
    && (\valid{Here}(p)<==>\valid{LoopEntry}(p))
    && (\valid_read{Here}(p)<==>\valid_read{LoopEntry}(p))
    && \allocation{Here}(p)==\allocation{LoopEntry}(p))
\end{listing-nonumber}

\begin{example}
~
\listinginput{1}{loop-frees.c}
The addresses of locations \lstinline|q[0..n]| are not modified by the loop,
but their values are.
The clause \lstinline|loop frees| catches the set of the memory blocks 
that may have been released by the previous loop iterations.
The first \lstinline|loop invariant| defines exactly these memory blocks.
On the other hand, \lstinline|loop frees| indicates that the remaining blocks
have not been freed since the beginning of the loop. Hence, they are still
\lstinline|\freeable| as expressed by the initial \lstinline|assert|, and
\lstinline|free(q[i])| will succeed at next step.
\end{example}

A {\sl loop-annot} without an allocation clause implicitly states \Loop \allocates \nothing.
That means the {\sl allocation status} is not modified by the loop body.
A {\sl loop-behavior} without allocation clause means that  
the allocated and deallocated memory blocks are in fact specified by the allocation clauses
of the {\sl loop-annot}
(The grammar of {\sl loop-annot} and {\sl loop-behaviors} is given in Figure~\ref{fig:gram:loops}).

\section{Sets and lists}

\review{Should set be instead \textbackslash set, so that it begins with a backslash, like all other built-in names and to avoid conflict with C++ names?}

\subsection{Finite sets}\label{sec:sets}
\index{location}
Sets of memory locations (tsets), as defined in Section~\ref{sec:locations},
can be used as first-class values in
annotations. All the elements of such a set must share the same type
(taking into account the usual implicit conversions).
Sets have the built-in type \lstinline|set<A>|\index{set@\texttt{set} type}
where \lstinline|A| is the type of terms contained in the set.

In addition, it is possible to consider sets of pointers to values of
different types. In this case, the set is of type
\lstinline|set<char*>| and
each of its elements \lstinline|e| is converted to
\lstinline|(char*)e + (0..sizeof(*e)-1)|.

\begin{example}
  The following example defines the \emph{footprint} of a
  structure, that is the set of locations that can be accessed from an
  object of this type.

  \listinginput{1}{footprint.c}

  In the first definition, since the arguments of union are a
  \lstinline|set<char*>| and a \lstinline|set<int*>|,
  the result is a \lstinline|set<char*>| (according to typing of union). In
  other words, the two definitions above are equivalent.

  This logic function can be used as an argument of \separated or of an
  \assigns clause.
\end{example}

Thus, the \separated predicate satisfies the following property (with
\lstinline|s$_1$| of type \lstinline|set<$\tau_1$*>| and \lstinline|s$_2$| of type
\lstinline|set<$\tau_2$*>|)
\begin{listing}{1}
\separated(s$_1$,s$_2$) <==>
  (\forall $\tau_1$* p; \forall $\tau_2$* q;
     \subset(p,s$_1$) && \subset(q,s$_2$) ==>
       (\forall \integer i,j;
         0 <= i < \sizeof($\tau_1$) && 0 <= j < \sizeof($\tau_2$) ==>
           (char*)p + i != (char*)q + j))
\end{listing}

and a clause \assigns \lstinline|L$_1$,$\ldots$,L$_n$| is equivalent
to the postcondition
\begin{listing-nonumber}
\forall char* p; \separated(\union(&L$_1$,$\ldots$,&L$_n$),p) ==> *p == \old(*p)
\end{listing-nonumber}



\subsection{Finite lists}\label{sec:lists}
The built-in type \lstinline|\list<A>|\indexttbs{list} can be used for finite 
sequences of elements of the same type \lstinline|A|. 
For constructing such homogeneous lists, built-in functions and notations are 
available.

The term \lstinline|\Nil|\indexttbs{Nil} denotes the empty sequence.
\begin{listing-nonumber}
\list<A> \Nil<A>;
\end{listing-nonumber}

The function \lstinline|\Cons|\indexttbs{Cons} prepends an element \lstinline|elt| 
onto a sequence \lstinline|tail|
\begin{listing-nonumber}
\list<A> \Cons<A>(<A> elt, \list<A> tail);
\end{listing-nonumber}
while \lstinline|\concat|\indexttbs{concat} concatenates two sequences
\begin{listing-nonumber}
\list<A> \concat<A>(\list<A> front, \list<A> tail);
\end{listing-nonumber}
and \lstinline|\repeat|\indexttbs{repeat} repeats a sequence \lstinline|n| times, \lstinline|n| being a positive number
\begin{listing-nonumber}
\list<A> \repeat<A>(\list<A> seq, integer n);
\end{listing-nonumber}

The semantics of these functions rely on two useful functions: 
\lstinline|\length|\indexttbs{length} returns the number of elements of 
a sequence \lstinline|seq| 
\begin{listing-nonumber}
integer \length<A>(\list<A> seq);
\end{listing-nonumber}
and \lstinline|\nth|\indexttbs{nth} returns the element that is at position 
\lstinline|n| of the given sequence \lstinline|seq|.
The first element is at position $0$. 
\begin{listing-nonumber}
<A> \nth<A>(\list<A> seq, integer n);
\end{listing-nonumber}

Last but not least, the functions \lstinline|\repeat| and \lstinline|\nth| 
aren't specified for negative number \lstinline|n|. 
The function \lstinline|\nth(l)| is also unspecified for index greater than or 
equal to \lstinline|\length(l)|.

The notation \lstinline![| |]! is just the same thing as \lstinline|\Nil| and
\lstinline![|1,2,3|]! is the sequence of three integers.
In addition the infix operator \lstinline|^| (resp. \lstinline|*^|) 
is the same as function \lstinline|\concat| (resp. \lstinline|\repeat|).
These infix operators have the same precedence as the conventional bit-wise exclusive-or operator
and are left-associative.

\begin{figure}[t]
  \begin{cadre}
      \input{list-gram.bnf}
    \end{cadre}
  \caption{Notations for built-in list datatype}
\label{fig:gram:list}
\end{figure}

\begin{example}
  The following example illustrates using such a data structure and 
  notations in connexion with ghost code.
  \listinginput{1}{list-observer.c}
  The function \lstinline|track| adds a value to the tail of a ghost trace variable. 
  Calls to that function inside ghost statements allow modifying that trace; 
  also properties of the \lstinline|observed_trace| can be specified. 
  Notice that the assigned ghost variable is \lstinline|ghost_trace|.
\end{example}


\section{Abrupt termination}
\label{sec:abrupt-clause}
\index{abrupt clause}

\begin{figure}[t]
  \begin{cadre}
     \input{exitbehavior.bnf}
    \end{cadre}
    \caption{Grammar of contracts about abrupt terminations}
  \label{fig:gram:abrupt-clauses}
\end{figure}

The \ensures\indextt{ensures} clause of function and statement contracts
does not constrain the post-state when the annotated function or
statement terminates abruptly. In such cases,
\textsl{abrupt clauses} can be used within \textsl{simple clause} or
\textsl{behavior body}. The allowed constructs are shown in
Figure~\ref{fig:gram:abrupt-clauses}.

The clauses \lstinline|breaks|\indextt{breaks}, \continues{}\indextt{continues} 
and \returns{}\indextt{returns}
can only be found in a statement contract and
state properties on the program state that hold when the
annotated statement terminates abruptly with the corresponding
statement (\lstinline|break|, \Continue{} or \lstinline|return|).

Inside these clauses, the construct \lstinline|\old(e)|\indexttbs{old}
is allowed and denotes, as for statement contracts
\lstinline|ensures|, \assigns and \lstinline|allocates|, the value of
\lstinline|e| in the pre-state of the statement.
 More generally, the visibility in \textsl{abrupt clauses} of predefined 
logic labels\indextt{Pre}\indextt{Here}\indextt{Old}\indextt{Post}
 (presented in Section~\ref{sec:default-logic-labels}) is the 
same as in \ensures{} clauses.

For the \lstinline|returns| case, the \result\indexttbs{result}
construct is allowed (if the function does not return \void) and is bound
to the returned value.

\begin{example}
  The following example illustrates each abrupt
  clause of statement contracts.
  \listinginput{1}{abrupt_termination.c}
\end{example}

The \exits{} clause can be used in both function and statement
contracts to give behavioral properties to the \main{} function
or to any function that may exit the program,
\emph{e.g.} by calling the \exit{} function.
The simple contract
\begin{listing-nonumber}
/*@ exits E;
  @*/
\end{listing-nonumber}
means that, if the program terminates while executing the corresponding
function (or statement), then it exits in a post-state where the property
E holds.
In any other termination kind, the \exits{} clause does not constrain
the post-state.

In such clauses, \lstinline|\old(e)|\indexttbs{old}
is allowed and denotes the value of \lstinline|e| in the pre-state of
the function or statement,
and \lstinline|\exit_status| is bound to the return code,
\emph{e.g.} the value returned by \main{} or the argument passed to \exit{}.
The  construct \lstinline|\exit_status|\indexttbs{exit\_status}
can be used only in \exits{},
 \assigns{} and \allocates{} clauses;
\result cannot be used in \exits{} clauses.

\begin{example}
\label{ex:assigns-and-abrupt-termination}
  Here is a complete specification of the \exit{} function, which
  performs an unconditional exit of the \main{} function:
  \listinginput{1}{exit.c}
  Note that the specification of the \lstinline|may_exit|
  function is incomplete since it allows modifications of the variable
  \lstinline|status| when no exit is performed.
  Using behaviors, it is possible to distinguish between the exit case
  and the normal case, as in the following specification:
  \listinginput{8}{mayexit.c}
\end{example}

%% DONE:
%% Discuter de la smantique du assign en prsence d'une terminaison abrupte
%% dans un contrat de fonction et de statement.
% [Patrick B.] START proposition:
In contrast to \ensures clauses, \assigns\indextt{assigns}, 
\allocates\indextt{allocates} and \frees\indextt{frees} clauses of function 
and statement contracts constrain the post-state 
even when the annotated function or statement terminates abruptly. 
This is shown in example~\ref{ex:assigns-and-abrupt-termination} for a function contract.
% END proposition:

\ifCPPinput{cpp-exceptions}
\ifCPPinput{cpp-attributes}
\ifCPPinput{cpp-functional}


%% TODO:
%%  Discuter de exit versus return pour la fonction main. Discuter
%%    du atexit() : le post-state de la clause exit est-il avant ou
%%    apres les fonctions enregistrees par atexit() ?

\section{Dependencies information}
\label{sec:func-dep}

\experimental

An extended syntax of \assigns clauses, described in
Figure~\ref{fig:gram:dep}, allows specifying data
dependencies\index{dependency} and
\notimplemented{\emph{functional expressions}}\index{functional expression}.

\begin{figure}[t]
  \begin{cadre}
      \input{dependencies.bnf}
    \end{cadre}
  \caption{Grammar for dependencies information}
\label{fig:gram:dep}
\end{figure}

Such a clause indicates that the assigned values can only depend upon
the locations mentioned in the \lstinline|\from| part of the
clause. Again, this is an over-approximation: all of the locations
involved in the computation of the modified values must be present,
but some of locations might not be used in practice. If the
\lstinline|\from| clause is absent, all of the locations reachable at the
given point of the program are supposed to be used.
Moreover, for a single location, it is possible to give the precise
relation between its final value and the value of its
dependencies. This expression is evaluated in the pre-state of the
corresponding contract.

\begin{example}
  The following example is a variation of the \lstinline+array_sum+
  function in example~\ref{ex:higherorder}, in which the values of
  the array are added to a global variable \lstinline+total+.

  \listinginput{1}{sum2.c}

\end{example}


\begin{example}
  % This example is referenced in a previous section.
  The composite element modifier operators 
  can be useful for writing such functional expressions.
  \listinginput{1}{modifier.c}
\end{example}

\section{Data invariants}
\label{sec:invariants}
\index{data invariant}\index{global invariant}\index{type invariant}
\index{invariant!data}\index{invariant!global}\index{invariant!type}
Data invariants are properties on data that are supposed to hold
permanently during the lifetime of these data. ACSL distinguishes
between
\begin{itemize}
\item \emph{global} invariants and \emph{type} invariants: the former
  only apply to specified global variables, whereas the latter are
  associated with a static type, and apply to any variables of
  the corresponding type;
\item \emph{strong} invariants and \emph{weak} invariants:
  \index{invariant!strong}\index{invariant!weak}
  strong
  invariants must be valid at any time during program execution
  (more precisely at any \emph{sequence point} as defined in the C
  standard), whereas weak invariants must be valid at \emph{function
    boundaries} (function entrance and exit) but can be violated in
  between.
\end{itemize}

\begin{figure}[t]
  \begin{cadre}
      \input{data_invariants.bnf}
    \end{cadre}
  \caption{Grammar for declarations of data invariants}
\label{fig:gram:datainvariants}
\end{figure}

The syntax for declaring data invariants is given in
Figure~\ref{fig:gram:datainvariants}. The strength modifier defaults
to \texttt{weak}.


\begin{example}
  In the following example, we declare
  \begin{enumerate}
  \item a weak global invariant \lstinline|a_is_positive|, which specifies that
    global variable \lstinline|a| should remain positive (weakly, so
    this property might be violated temporarily between function
    calls);
  \item a strong type invariant for variables of type \lstinline|temperature|;
  \item a weak type invariant for variables of type \lstinline|struct S|.
  \end{enumerate}
  \listinginput{1}{invariants.c}
\end{example}

\subsection{Semantics}

The distinction between strong and weak invariants has to do with the
sequence points where the property is supposed to hold. The distinction
between global and type invariants has to do with the set of values on
which they are supposed to hold.

\begin{itemize}
\item Weak global invariants are properties that apply to global
  data and hold at any function entrance and function exit.

\item Strong global invariants are properties that apply to global
  data and hold at any step during execution (starting after
  initialization of these data).

\item A weak type invariant on type $\tau$ must hold at any function
  entrance and exit, and applies to any value (variable, field, array element, formal
  parameter, etc.) with static type $\tau$. If the result of a
  function is of type $\tau$, that result must also satisfy its
  weak invariant at function exit. 

\item A strong type invariant on type $\tau$ must hold at any step 
(more precisely, ay sequence point as defined in C)
  during execution, and applies to any global variable, local
  variable, or formal parameter\index{formal parameter}
  with static type $\tau$. If the
  result of a function has type $\tau$, that result must also
  satisfy its strong invariant at function exit.

\end{itemize}


\begin{example}
  \notimplemented{The following example illustrates the use of a weak data invariant on a local static variable.}

  \listinginput{1}{out_char.c}
\end{example}

\begin{example}
  Here is a longer example, the famous Dijkstra's Dutch flag algorithm.\\
  \listinginput{1}{flag.c}
\end{example}
Note that in this example the invariant could be declared \lstinline|strong|. However, not all C \lstinline|enum|s would 
obey a corresponding invariant, because in C, \lstinline|enum| values are just \lstinline|int|s and can hold values other
than those listed in the declaration of the \lstinline|enum| type.

\ifCPPinput{cpp-class-invariants}

\subsection{Model variables and model fields}
\label{sec:model}
\indextt{model} \notimplemented{A \emph{model variable} is a variable
  introduced in the specification with the keyword
  \lstinline|model|}. Its type must be a logic type. Analogously,
types may have \emph{model fields}.  These are
used to provide abstract specifications for functions whose concrete
implementation must remain private.

\begin{figure}[b]
  \begin{cadre}
      \input{model.bnf}
    \end{cadre}
  \caption{Grammar for declarations of model variables and fields}
\label{fig:gram:model}
\end{figure}


The precise syntax for declaring model variables and fields is given
in Figure~\ref{fig:gram:model}. It is presented as additions to the
regular C grammar for declarations.

The informal semantics of model variables is as follows.
\begin{itemize}
\item Model variables can only appear in specifications. They are not
  lvalues, thus they cannot be assigned directly (unlike ghost variables,
  see below).
\item Nevertheless, a function contract might state that a model variable
  is assigned, meaning that the value of the model variable may be different between the pre and post states of the contract.
\item When a function contract mentions model variables:
  \begin{itemize}
  \item the precondition is implicitly existentially quantified over
    those variables;
  \item the postconditions are universally quantified over the old
    values of model variables, and existentially quantified over the new values.
  \end{itemize}
\end{itemize}
Thus, in practice, the only way to prove that a function body
satisfies a contract with model variables is to provide an invariant
relating model variables and concrete variables, as in the example
below.

Model fields behave the same, but they are attached to any value whose static
type is the one of the model declaration. A model field can be attached to any
C type, not only to \texttt{struct}. When it is attached to a compound type,
however, it must not have the same name as a C field of that compound type.
In addition, model fields are ``inherited'' by a \texttt{typedef} 
in the sense that the newly defined type has also the model fields of its
parents (and can acquire more, which will not be present for the parent).
For instance, in the following code, \texttt{t1} has one model field
\texttt{m1}, while \texttt{t2} has two model fields,
\texttt{m1} and \texttt{m2}.
\begin{lstlisting}[style=c,basicstyle=\lp@basic,numbers=left]
typedef int t1;
typedef t1 t2;
/*@ model t1 { int m1 }; */
/*@ model t2 { int m2 }; */
\end{lstlisting}

\begin{example}\label{ex:model}
  Here is an example of a specification for a function that generates
  fresh integers. The contract is given in terms of a model variable
  that is intended to represent the set of ``forbidden'' values,
  e.g. the values that have already been generated.
  \listinginput{1}{gen_spec_with_model.c}
  The contract is expressed abstractly, telling that
  \begin{itemize}
  \item the forbidden set of values is modified;
  \item the value returned is not in the set of forbidden values, thus
    it is ``fresh'';
  \item the new set of forbidden values contains both the value
    returned and the previous forbidden values.
    The new set may have more values than the union of \lstinline|{\result}| 
    and \lstinline|\old(forbidden)|.
  \end{itemize}
  An implementation of this function might be as follows, where a
  decision has been made to generate values in increasing order, so
  that it is sufficient to record the last value generated. This decision
  is made explicit by an invariant.
  \listinginput{1}{gen_code.c}
\end{example}

\paragraph{Remarks}

Although the syntax of model variables is close to JML model
variables, they differ in the sense that the type of a model variable
is a logic type, not a C type. Also, the semantics above is closer to
the one of B machines~\cite{abrial96:_b_book}. It should be noticed
that program verification with model variables does not have a
well-established theoretical background~\cite{marche07,leavens07}, so
we deliberately do not provide a precise semantics in this document.

\section{Ghost variables and statements}
\label{sec:ghost}
\indextt{ghost}
Ghost variables and statements are like C variables and statements,
but visible only in the specifications. They are introduced by the
\lstinline|ghost| keyword at the beginning of the annotation
(i.e. \lstinline|/*@ ghost ... */| or \lstinline|//@ ghost ...|
for one-line
ghost code, as mentioned in section~\ref{sec:gener-about-annot}).
The grammar is given in Figure~\ref{fig:gram:ghost}, in which only the
first form of annotation is used. In this figure, the \textit{C-*}
non-terminals refer to the corresponding grammar rules of the ISO standard,
without any ACSL extension. Any non-terminal of the form
\textit{ghost-non-term} for which no definition is given in the figure
represents the corresponding \textit{C-non-term} entry, in which any
\textit{entry} is substituted by \textit{ghost-entry}.

The variations with respect to the C
grammar are the following:
\begin{itemize}
\item Comments within ghost code must be introduced by \lstinline|//| and extend until the
  end of the line (the ghost code itself is placed inside a C
  comment, so an embedded comment of the form \lstinline|/* ... */| would be incorrect C code).
\item It is however possible to write multi-line annotations inside ghost
  code. These annotations are enclosed between
  \lstinline|/@| and \lstinline|@/|
  (since as indicated above, \lstinline|/*@ ... */| would lead
  to incorrect C code).
  As in normal annotations, \lstinline|@| characters (most commonly at the beginning of a
  line and at the end of an annotation, before the final \lstinline|@/|) are
  considered to be white space. 
  This style of annotation is only needed and permitted within ghost code.
  Also, ghost code may not be written within enclosing ghost code.
  
\item \notimplemented{Logical types, such as \lstinline|integer| or
\lstinline|real| are authorized in ghost code}.
\item \notimplemented{A non-ghost function can take ghost
    parameters}.
  If such a ghost
  clause is present in the declarator, then the list of ghost
  parameters must be non-empty and fixed (no vararg ghost). The call
  to the function must then provide the appropriate number of ghost parameters.
\item Any non-ghost \textit{if-statement} that does not have a non-ghost
  \lstinline|else| clause \notimplemented{can be augmented with a ghost
    one}. Similarly, a non-ghost
  \lstinline|switch| can have \notimplemented{a ghost \lstinline|default:|
    clause}
  if it does not have a non-ghost one
  (there are however semantic restrictions for valid
  ghost labelled statements in a switch, see next paragraph for details).
\end{itemize}

\begin{figure}[t]
  \begin{cadre}
      \input{ghost.bnf}
    \end{cadre}
  \caption{Grammar for ghost statements}
\label{fig:gram:ghost}
\end{figure}


\paragraph{Semantics of Ghost Code}
\label{sec:semantics-ghost-code}
The question of semantics is essential for ghost code.
\notimplemented[Not checked in the current implementation]{Informally, the
semantics requires that ghost statements do not change the regular
program execution.} This implies several conditions, including e.g.:
\begin{itemize}
\item Ghost code cannot modify a non-ghost C variable.
\item Ghost code cannot modify a non-ghost structure field.
\item If \lstinline|p| is a ghost pointer pointing to a non-ghost
  memory location, then it is forbidden to assign \lstinline|*p|.
\item The body of a ghost function is ghost code, and hence may not modify
  non-ghost variables or fields.
\item If a non-ghost C function is called in ghost code, it must not
  modify non-ghost variables or fields.
\item If a structure has ghost fields, the \lstinline|sizeof| of the
  structure is the same as the structure without ghost fields. Also,
  alignment of fields remains unchanged.
\item The control-flow graph of a function must not be altered by
  ghost statements. In particular, no ghost \lstinline|return| can appear
  in the body of a non-ghost function. Similarly, ghost
  \lstinline|goto|, \lstinline|break|, and 
  \lstinline|continue| cannot jump
  outside of the innermost non-ghost enclosing block.
\end{itemize}

The semantics is specified as follows. First, the
execution of a program with ghost code involves a \emph{ghost memory heap}
and a \emph{ghost stack}, disjoint from the regular heap and stack.
Ghost variables lie in the ghost heap, as do the ghost fields of
structures. Thus, every memory side-effect can be classified as ghost
or non-ghost. Then, the semantics is that any memory side-effects of ghost
code must be only in the ghost heap or the ghost stack.

Notice that this semantics is not statically decidable.
\notimplemented{It is left to tools to provide approximations},
correct in the sense that any code
statically detected as ghost must be semantically ghost.

\begin{example}
  The following example shows some invalid assignments of ghost pointers:
  \listinginput{1}{ghostpointer.c}
\end{example}

\begin{example}
  The following example shows some invalid ghost statements:
  \listinginput{1}{ghostcfg.c}
\end{example}

\paragraph{Differences between model variables and ghost variables}

A ghost variable is an additional specification variable that is
assigned in ghost code like any C variable. On the other hand, a model
variable cannot be assigned, but one can state it is modified and can
express properties about the new value, in a non-deterministic way,
using logic assertions and invariants.
In other words, specifications using ghost variable assignments
are executable.

\begin{example}
  \label{ex:gen_code}
  The example~\ref{ex:model} can also be specified with a ghost
  variable instead of a model variable:

  \listinginput{1}{gen_spec_with_ghost.c}

\end{example}

\subsection{Volatile variables}\label{sec:volatile-variables}
\indextt{volatile}

Volatile variables can not be used in logic terms, since reading such
a variable may have a side effect, in particular two successive reads
may return different values.

\begin{figure}[ht]
  \begin{cadre}
      \input{volatile-gram.bnf}
    \end{cadre}
  \caption{Grammar for volatile constructs}
\label{fig:gram:volatile}
\end{figure}

Specifying properties of a volatile variable may be done via a
specific construct to attach two ghost functions to it. This
construct, described by the grammar of Figure~\ref{fig:gram:volatile}, has
the following shape:
\begin{lstlisting}[style=c-basic,firstnumber=1,name=volatile,numbers=left]
volatile $\tau$ x;
\end{lstlisting}
\begin{lstlisting}[style=c-basic,name=volatile,numbers=left]
//@ volatile x reads f writes g;
\end{lstlisting}
where \lstinline|f| and \lstinline|g| are ghost functions with the following prototypes:
\begin{lstlisting}[style=c-basic,name=volatile,numbers=left]
$\tau$ f(volatile $\tau$* p);
$\tau$ g(volatile $\tau$* p, $\tau$ v);
\end{lstlisting}
This must be understood as a special construct to instrument the C
code, where each access to the variable \lstinline|x| is replaced by a call
to \lstinline|f(&x)|, and each assignment to \lstinline|x| of a value
\lstinline|v|
is replaced by \lstinline|g(&x,v)|. If a given volatile variable is only read 
or only written to, the unused accessor function can be omitted from the 
\lstinline|volatile| construct.

\begin{example}
  The following code is instrumented in order to inject fixed values
  at each read of variable \lstinline|x|, and collect written values.
  \listinginput{1}{volatile.c}
\end{example}



\begin{figure}[t]
  \begin{cadre}
      \input{initialized.bnf}
    \end{cadre}
  \caption{Grammar extensions regarding initialized and dangling memory}
\label{fig:gram:initialized}
\end{figure}

\section{Initialization and undefined values}
\label{sec:initialized}
\indexttbs{initialized}
\lstinline|\initialized{L}(p)| is a predicate taking a set of pointers
(having a type other than \lstinline|void*|) to l-values as
argument (cf. Fig.~\ref{fig:gram:initialized}) and means that each l-value in this set is initialized at label \lstinline|L|.
\\ \makebox[5mm]{} \lstinline|\initialized{id} : set<$\alpha$*> $\ra$ bool|

\begin{example}
  In the following, the assertion is true.
  \listinginput{1}{initialized.c}
  Default labels are 
  such that logic label \lstinline|{Here}| can be omitted.
\end{example}

\section{Dangling pointers}
\label{sec:dangling_pointers}
\indexttbs{dangling}
\lstinline|\dangling{L}(p)|
is a predicate taking a set of pointers
(having a type other than \lstinline|void*|) to l-values as
argument (cf. Fig.~\ref{fig:gram:initialized}) and means that each l-value in this set has a \emph{dangling
  content} at label \lstinline|L|. That is, its value is (or contains bits
of) a dangling address: either the address of a local
variable referred to outside of its scope or the address of a variable that
has been dynamically allocated, then deallocated.
\\ \makebox[5mm]{} \lstinline|\dangling{id} : set<$\alpha$*> $\ra$ bool|

\begin{example}
  In the following, the assertion holds.
  \listinginput{1}{dangling.c}
\end{example}

In most cases, the arguments to \lstinline|\dangling| are pointers to
l-values that themselves have type pointer, so the usual signature
of \lstinline|\dangling| is actually
\lstinline|set<$\alpha$**> $\ra$ bool|.
The signature \lstinline|set<$\alpha$*> $\ra$ bool| is useful to handle
pointer values that have been written inside scalar variables through
heterogeneous casts.

Note that \lstinline|\dangling| takes a set of memory locations as its argument.
The predicate is true if \emph{all} of the memory locations contained in the argument are dangling. That
semantics implies that \lstinline|!\dangling(s)| is true precisely when at least one
of the locations in $s$ is not dangling. \lstinline|!\dangling(s)| does \emph{not} mean that 
\emph{all} of the indicated memory locations are \emph{not dangling}, only that \emph{some} are.

\section{Well-typed pointers}
\label{sec:welltyped}
\experimental
\indextt{valid\_function}

\begin{figure}[h]
  \begin{cadre}
      \input{welltyped.bnf}
    \end{cadre}
  \caption{Grammar for predicates related to well-typedness }
\label{fig:gram:welltyped}
\end{figure}

The predicates of Figure~\ref{fig:gram:welltyped} are used to relate
the type of a pointer to the effective type of the memory location or function
that is being pointed to.

Currently, only the compatibility of a function pointer with the type of
the function it points to is axiomatized, through the predicate
\lstinline|\valid_function|. This predicate has type
\lstinline|set<$\alpha$*> $\ra$ bool|,
and \lstinline|\valid_function(p)| holds if and only if
\begin{itemize}
\item \lstinline|p| is a pointer to a function of type \lstinline|t|, and
\item \lstinline|*p| is a function whose type is \emph{compatible}
  with \lstinline|t|, in the sense of \cite[\S6.2.7]{standardc99}
\end{itemize}

\begin{example}
  In the following, the assertions are true.
  \listinginput{1}{welltyped.c}
\end{example}


\section{Module constructions}

\experimental

how to encapsulate several functions...

\ifCPPinput{preprocessing}

\section{Logic attribute annotations}
\label{sec:attribute_annot}

\experimental

These are annotations allowing to add attributes on variables, like regular C attributes (const, volatile, restrict).

\ifCPP{
\section{Questions and items to consider adding}
\begin{itemize}
	\item logic lambda expressions; allow a lambda expression in a decreases clause, loop variant clause and in volatile clauses
	\item add nodangling or alter semantics of dangling
	\item is the rule concerning strong purity too draconian? (\S\ref{sec:pure})
	\item should set be textbackslash set
	\ifCPP{\item discussion on how to specify and reason about \lang iterators}
	
\end{itemize}
}

\ifCPP{ \TODO{}
\section{Other items to include somewhere}
\begin{itemize}
	\item name resolution for ACSL++ names
	\item unsequenced behavior, e.g. i = v[i++]
	\item which are reserved words
	\item initialization (C++ ref 3.6.2)
	\item restrictions on invariant footprint
	\item examples of reasoning about types
	\item should min and max accept any number of arguments
	\item clearer explanation of exact computations
	\item clearer explanation of equality of unions
	\item The loop annotations section needs an example
	\item The general inductive invariants section needs an example
	\item Discuss strong and weak invariants with respect to sequence points
	\item need an example and use case of dynamically dispatched class invariants
	\item should lambda expressions be allowed instead of idents in volatile declarations; must the idents be ghost functions?
	\item should set be \textbackslash set
	\item expressions for function types
	\item Annotate the standard library
	\item Annotate an example code base
	\item Jens: There should be some text on how the kinds of C++ reference types are treated in ACSL++ (compared to the treatment of pointers in ACSL).
	\item ownership?
	\item \textbackslash constructed
	\item ghost arrays
	\item can't do a reference in let
	\item reference functcion parameters are in and out -- does that work properly?
	\item Is a grammar needed for \S\ref{sec:aggregate}
	\item C++: Check that defaults specs when [[noreturn]] is present are what is expected
\end{itemize}
}

% The purpose of these are various:
% \begin{itemize}
% \item specific verifications, like \url{http://www.cs.umd.edu/~jfoster/cqual}
% \item specific analyses, like region
%   analyses~\cite{hubert07hav} a la Cyclone~\cite{grossman02pldi}.
% \item allowing to attach model variables/fields to types that are not
%   structures~\cite{filliatr07queens}.
% \end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% ispell-local-dictionary: "english"
%%% End:
